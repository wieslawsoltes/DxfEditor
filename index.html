<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Minimal OOP Drawing App (MVVM, DXF) with Pan/Zoom, Block & Entity Editing with Resizing</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 16px;
    }
    #canvasContainer {
      border: 1px solid #ccc;
      width: 800px;
      height: 600px;
      position: relative;
      overflow: hidden;
    }
    #drawingCanvas {
      position: absolute;
      top: 0;
      left: 0;
    }
    #toolbar {
      margin-bottom: 8px;
    }
    button {
      margin-right: 4px;
      font-size: 20px;
    }
    textarea {
      width: 100%;
      height: 120px;
    }
    /* Modal styles for block and entity editor */
    #blockEditorOverlay, #entityEditorOverlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.5);
      z-index: 900;
    }
    #blockEditorModal, #entityEditorModal {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #fff;
      border: 1px solid #ccc;
      padding: 16px;
      z-index: 1000;
      width: 400px;
      box-shadow: 0 0 10px rgba(0,0,0,0.5);
    }
    #blockEditorModal textarea, #entityEditorModal textarea {
      width: 100%;
      height: 200px;
    }
    #blockEditorModal button, #entityEditorModal button {
      margin-top: 8px;
      margin-right: 4px;
    }
  </style>
</head>
<body>

<div id="toolbar">
  <button id="newDrawing" title="New Drawing">üÜï</button>
  <button id="panTool" title="Pan">‚úã</button>
  <button id="selectTool" title="Select">üñ±</button>
  <button id="lineTool" title="Line">üìè</button>
  <button id="rectTool" title="Rectangle (via Polyline)">‚ñ≠</button>
  <button id="circleTool" title="Circle">‚ö™</button>
  <button id="textTool" title="Text">‚úèÔ∏è</button>
  <button id="polylineTool" title="Polyline">„Ä∞Ô∏è</button>
  <button id="createBlock" title="Create BLOCK from Selection">üì¶</button>
  <button id="insertBlock" title="INSERT Block">‚ûï</button>
  <button id="editBlock" title="Edit Block">üõ†Ô∏è</button>
  <button id="editEntity" title="Edit Entity">üìù</button>
  <button id="saveDXF" title="Save DXF">üíæ</button>
  <input type="file" id="loadDXFFile" accept=".dxf,text/plain" />
</div>

<div id="canvasContainer">
  <canvas id="drawingCanvas" width="800" height="600"></canvas>
</div>

<p>
  <strong>DXF Output / Debug:</strong><br>
  <textarea id="dxfOutput" readonly></textarea>
</p>

<!-- Block Editor Modal -->
<div id="blockEditorOverlay"></div>
<div id="blockEditorModal">
  <h3>Edit Block</h3>
  <textarea id="blockEditorTextarea"></textarea>
  <br>
  <button id="saveBlockEdit">Save Block Edit</button>
  <button id="cancelBlockEdit">Cancel</button>
</div>

<!-- Entity Editor Modal -->
<div id="entityEditorOverlay"></div>
<div id="entityEditorModal">
  <h3>Edit Entity</h3>
  <textarea id="entityEditorTextarea"></textarea>
  <br>
  <button id="saveEntityEdit">Save Entity Edit</button>
  <button id="cancelEntityEdit">Cancel</button>
</div>

<script>
/*
  ===============================
  ========== Model ==============
  ===============================
*/

class Entity {
  constructor() {
    this.selected = false; // For selection highlight
  }
}

class LineEntity extends Entity {
  constructor(x1, y1, x2, y2) {
    super();
    this.x1 = x1;
    this.y1 = y1;
    this.x2 = x2;
    this.y2 = y2;
  }
  isHit(x, y) { return HitTestingService.isLineHit(this, x, y); }
  move(dx, dy) {
    this.x1 += dx;
    this.y1 += dy;
    this.x2 += dx;
    this.y2 += dy;
  }
}

class PolylineEntity extends Entity {
  constructor(vertices, closed = false) {
    super();
    this.vertices = vertices || [];
    this.closed = closed;
  }
  isHit(x, y) {
    return HitTestingService.isPolylineHit(this, x, y);
  }
  move(dx, dy) {
    this.vertices.forEach(v => {
      v.x += dx;
      v.y += dy;
    });
  }
}

class CircleEntity extends Entity {
  constructor(cx, cy, r) {
    super();
    this.cx = cx;
    this.cy = cy;
    this.r = r;
  }
  isHit(x, y) {
    return HitTestingService.isCircleHit(this, x, y);
  }
  move(dx, dy) {
    this.cx += dx;
    this.cy += dy;
  }
}

class TextEntity extends Entity {
  constructor(x, y, text) {
    super();
    this.x = x;
    this.y = y;
    this.text = text || "Text";
  }
  isHit(x, y) {
    return HitTestingService.isTextHit(this, x, y);
  }
  move(dx, dy) {
    this.x += dx;
    this.y += dy;
  }
}

/**
 * A block is essentially a named definition containing a list of entities.
 */
class Block {
  constructor(name, entities = []) {
    this.name = name;
    this.entities = entities.map(e => cloneEntity(e));
  }
}

/**
 * INSERT references a Block by name, with a position.
 */
class InsertEntity extends Entity {
  constructor(blockName, x, y) {
    super();
    this.blockName = blockName;
    this.x = x;
    this.y = y;
  }
  isHit(px, py) {
    return HitTestingService.isInsertHit(this, px, py, drawing.blocks);
  }
  move(dx, dy) {
    this.x += dx;
    this.y += dy;
  }
}

/**
 * The main Drawing model that contains top-level entities and block definitions.
 */
class Drawing {
  constructor() {
    this.entities = [];
    this.blocks = {}; // { blockName: Block, ... }
  }
}

/*
  ===============================
  ======== Bounds Service =======
  ===============================
*/
class BoundsService {
  static getEntityBounds(e) {
    if (e instanceof LineEntity) {
      return {
        minX: Math.min(e.x1, e.x2),
        minY: Math.min(e.y1, e.y2),
        maxX: Math.max(e.x1, e.x2),
        maxY: Math.max(e.y1, e.y2)
      };
    } else if (e instanceof PolylineEntity) {
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      e.vertices.forEach(v => {
        minX = Math.min(minX, v.x);
        minY = Math.min(minY, v.y);
        maxX = Math.max(maxX, v.x);
        maxY = Math.max(maxY, v.y);
      });
      return { minX, minY, maxX, maxY };
    } else if (e instanceof CircleEntity) {
      return {
        minX: e.cx - e.r,
        minY: e.cy - e.r,
        maxX: e.cx + e.r,
        maxY: e.cy + e.r
      };
    } else if (e instanceof TextEntity) {
      return {
        minX: e.x,
        minY: e.y - 16,
        maxX: e.x + 50,
        maxY: e.y
      };
    } else if (e instanceof InsertEntity) {
      return {
        minX: e.x,
        minY: e.y,
        maxX: e.x,
        maxY: e.y
      };
    }
    return { minX: 0, minY: 0, maxX: 0, maxY: 0 };
  }
}

/*
  ===============================
  ========== Hit Testing =========
  ===============================
*/
class HitTestingService {
  static pointLineDistance(px, py, x1, y1, x2, y2) {
    const A = px - x1;
    const B = py - y1;
    const C = x2 - x1;
    const D = y2 - y1;
    const dot = A * C + B * D;
    const len_sq = C * C + D * D;
    let param = (len_sq !== 0) ? dot / len_sq : -1;
    let xx, yy;
    if (param < 0) {
      xx = x1; yy = y1;
    } else if (param > 1) {
      xx = x2; yy = y2;
    } else {
      xx = x1 + param * C;
      yy = y1 + param * D;
    }
    const dx = px - xx;
    const dy = py - yy;
    return Math.sqrt(dx * dx + dy * dy);
  }

  static isLineHit(entity, x, y) {
    return this.pointLineDistance(x, y, entity.x1, entity.y1, entity.x2, entity.y2) < 5;
  }

  static isPolylineHit(entity, x, y) {
    for (let i = 0; i < entity.vertices.length - 1; i++) {
      const v1 = entity.vertices[i];
      const v2 = entity.vertices[i + 1];
      if (this.pointLineDistance(x, y, v1.x, v1.y, v2.x, v2.y) < 5) {
        return true;
      }
    }
    if (entity.closed && entity.vertices.length > 1) {
      const v1 = entity.vertices[entity.vertices.length - 1];
      const v2 = entity.vertices[0];
      if (this.pointLineDistance(x, y, v1.x, v1.y, v2.x, v2.y) < 5) {
        return true;
      }
    }
    return false;
  }

  static isCircleHit(entity, x, y) {
    const dx = entity.cx - x;
    const dy = entity.cy - y;
    return Math.sqrt(dx * dx + dy * dy) <= entity.r + 5;
  }

  static isTextHit(entity, x, y) {
    let width = 50;
    const tempCanvas = document.createElement('canvas').getContext('2d');
    tempCanvas.font = "16px sans-serif";
    width = tempCanvas.measureText(entity.text).width;
    const height = 16;
    return (x >= entity.x && x <= entity.x + width &&
            y <= entity.y && y >= entity.y - height);
  }

  static isInsertHit(entity, x, y, blocks) {
    const block = blocks[entity.blockName];
    if (block && block.entities.length > 0) {
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      block.entities.forEach(e => {
          const b = BoundsService.getEntityBounds(e);
          minX = Math.min(minX, b.minX);
          minY = Math.min(minY, b.minY);
          maxX = Math.max(maxX, b.maxX);
          maxY = Math.max(maxY, b.maxY);
      });
      minX += entity.x;
      minY += entity.y;
      maxX += entity.x;
      maxY += entity.y;
      if (x >= minX && x <= maxX && y >= minY && y <= maxY) return true;
    }
    const dx = x - entity.x;
    const dy = y - entity.y;
    return Math.sqrt(dx * dx + dy * dy) < 10;
  }
}

/*
  ===============================
  ========== Utilities ==========
  ===============================
*/

function cloneEntity(entity) {
  if (entity instanceof LineEntity) {
    return new LineEntity(entity.x1, entity.y1, entity.x2, entity.y2);
  } else if (entity instanceof PolylineEntity) {
    const verts = entity.vertices.map(v => ({x: v.x, y: v.y}));
    return new PolylineEntity(verts, entity.closed);
  } else if (entity instanceof CircleEntity) {
    return new CircleEntity(entity.cx, entity.cy, entity.r);
  } else if (entity instanceof TextEntity) {
    return new TextEntity(entity.x, entity.y, entity.text);
  } else if (entity instanceof InsertEntity) {
    return new InsertEntity(entity.blockName, entity.x, entity.y);
  }
  return null;
}

/*
  ===============================
  ========== Drawing Service ==========
  ===============================
*/
class DrawingService {
  static drawEntity(entity, ctx, blocks) {
    if (entity instanceof LineEntity) {
      ctx.save();
      ctx.beginPath();
      ctx.strokeStyle = entity.selected ? 'red' : 'black';
      ctx.moveTo(entity.x1, entity.y1);
      ctx.lineTo(entity.x2, entity.y2);
      ctx.stroke();
      ctx.restore();
    } else if (entity instanceof PolylineEntity) {
      if (entity.vertices.length === 0) return;
      ctx.save();
      ctx.beginPath();
      ctx.strokeStyle = entity.selected ? 'red' : 'black';
      ctx.moveTo(entity.vertices[0].x, entity.vertices[0].y);
      for (let i = 1; i < entity.vertices.length; i++) {
        ctx.lineTo(entity.vertices[i].x, entity.vertices[i].y);
      }
      if (entity.closed) {
        ctx.closePath();
      }
      ctx.stroke();
      ctx.restore();
    } else if (entity instanceof CircleEntity) {
      ctx.save();
      ctx.beginPath();
      ctx.strokeStyle = entity.selected ? 'red' : 'black';
      ctx.arc(entity.cx, entity.cy, entity.r, 0, 2 * Math.PI);
      ctx.stroke();
      ctx.restore();
    } else if (entity instanceof TextEntity) {
      ctx.save();
      ctx.font = "16px sans-serif";
      ctx.fillStyle = 'black';
      if (entity.selected) {
        ctx.strokeStyle = 'red';
        ctx.beginPath();
        ctx.moveTo(entity.x, entity.y);
        const textWidth = ctx.measureText(entity.text).width;
        ctx.lineTo(entity.x + textWidth, entity.y);
        ctx.stroke();
      }
      ctx.fillText(entity.text, entity.x, entity.y);
      ctx.restore();
    } else if (entity instanceof InsertEntity) {
      const block = blocks[entity.blockName];
      if (!block) return;
      ctx.save();
      ctx.translate(entity.x, entity.y);
      for (let e of block.entities) {
        DrawingService.drawEntity(e, ctx, blocks);
      }
      ctx.restore();
      if (entity.selected) {
        ctx.save();
        ctx.strokeStyle = 'red';
        ctx.beginPath();
        ctx.arc(entity.x, entity.y, 5, 0, 2 * Math.PI);
        ctx.stroke();
        ctx.restore();
      }
    }
  }
}

/*
  ===============================
  ========== Resize Helpers ==========
  ===============================
*/

// Returns an array of handle objects (each with an id, x, and y)
function getSelectionHandles(bounds) {
  const midX = (bounds.minX + bounds.maxX) / 2;
  const midY = (bounds.minY + bounds.maxY) / 2;
  return [
    { id: 'nw', x: bounds.minX, y: bounds.minY },
    { id: 'n',  x: midX,       y: bounds.minY },
    { id: 'ne', x: bounds.maxX, y: bounds.minY },
    { id: 'e',  x: bounds.maxX, y: midY },
    { id: 'se', x: bounds.maxX, y: bounds.maxY },
    { id: 's',  x: midX,       y: bounds.maxY },
    { id: 'sw', x: bounds.minX, y: bounds.maxY },
    { id: 'w',  x: bounds.minX, y: midY }
  ];
}

// Given the original (cloned) entity, its original bounding box and new bounding box,
// compute scale factors and update the current entity‚Äôs geometry accordingly.
function updateEntityFromResize(original, current, origBounds, newBounds, scaleX, scaleY) {
  if (original instanceof LineEntity) {
    current.x1 = newBounds.minX + (original.x1 - origBounds.minX) * scaleX;
    current.y1 = newBounds.minY + (original.y1 - origBounds.minY) * scaleY;
    current.x2 = newBounds.minX + (original.x2 - origBounds.minX) * scaleX;
    current.y2 = newBounds.minY + (original.y2 - origBounds.minY) * scaleY;
  } else if (original instanceof PolylineEntity) {
    current.vertices = original.vertices.map(v => ({
      x: newBounds.minX + (v.x - origBounds.minX) * scaleX,
      y: newBounds.minY + (v.y - origBounds.minY) * scaleY
    }));
  } else if (original instanceof CircleEntity) {
    current.cx = newBounds.minX + (original.cx - origBounds.minX) * scaleX;
    current.cy = newBounds.minY + (original.cy - origBounds.minY) * scaleY;
    current.r = original.r * ((scaleX + scaleY) / 2);
  } else if (original instanceof TextEntity) {
    current.x = newBounds.minX + (original.x - origBounds.minX) * scaleX;
    current.y = newBounds.minY + (original.y - origBounds.minY) * scaleY;
  } else if (original instanceof InsertEntity) {
    current.x = newBounds.minX + (original.x - origBounds.minX) * scaleX;
    current.y = newBounds.minY + (original.y - origBounds.minY) * scaleY;
  }
}

/*
  ===============================
  ========== ViewModel ==========
  ===============================
*/
class DrawingViewModel {
  constructor(drawing) {
    this.drawing = drawing;
    this.tempEntity = null;
    this.startX = 0;
    this.startY = 0;
    this.isDragging = false;
    this.blockToInsert = null;
    // NEW properties for resizing:
    this.resizing = false;
    this.resizingEntity = null;
    this.resizeHandle = null;
    this.resizeOriginalEntity = null;
    this.resizeOriginalBounds = null;
  }

  findHitEntity(x, y) {
    for (let i = this.drawing.entities.length - 1; i >= 0; i--) {
      const ent = this.drawing.entities[i];
      let hit = false;
      if (ent instanceof InsertEntity) {
        hit = HitTestingService.isInsertHit(ent, x, y, this.drawing.blocks);
      } else {
        hit = ent.isHit(x, y);
      }
      if (hit) return ent;
    }
    return null;
  }

  clearSelection() {
    this.drawing.entities.forEach(e => e.selected = false);
  }

  moveSelection(dx, dy) {
    for (let ent of this.drawing.entities) {
      if (ent.selected) {
        ent.move(dx, dy);
      }
    }
  }

  offsetEntity(entity, dx, dy) {
    if (entity instanceof LineEntity) {
      return new LineEntity(entity.x1 - dx, entity.y1 - dy, entity.x2 - dx, entity.y2 - dy);
    } else if (entity instanceof PolylineEntity) {
      const newVerts = entity.vertices.map(v => ({x: v.x - dx, y: v.y - dy}));
      return new PolylineEntity(newVerts, entity.closed);
    } else if (entity instanceof CircleEntity) {
      return new CircleEntity(entity.cx - dx, entity.cy - dy, entity.r);
    } else if (entity instanceof TextEntity) {
      return new TextEntity(entity.x - dx, entity.y - dy, entity.text);
    }
    return null;
  }

  createBlockFromSelection(blockName) {
    const selectedEntities = this.drawing.entities.filter(e => e.selected);
    if (selectedEntities.length === 0) return;
    let globalBounds = null;
    selectedEntities.forEach(e => {
      const b = BoundsService.getEntityBounds(e);
      if (!globalBounds) {
        globalBounds = { minX: b.minX, minY: b.minY, maxX: b.maxX, maxY: b.maxY };
      } else {
        globalBounds.minX = Math.min(globalBounds.minX, b.minX);
        globalBounds.minY = Math.min(globalBounds.minY, b.minY);
        globalBounds.maxX = Math.max(globalBounds.maxX, b.maxX);
        globalBounds.maxY = Math.max(globalBounds.maxY, b.maxY);
      }
    });
    const offsetX = globalBounds.minX;
    const offsetY = globalBounds.minY;
    const offsetEntities = selectedEntities.map(e => this.offsetEntity(e, offsetX, offsetY))
                                            .filter(e => e !== null);
    this.drawing.blocks[blockName] = new Block(blockName, offsetEntities);
    selectedEntities.forEach(ent => { ent.selected = false; });
  }

  setBlockToInsert(blockName) {
    this.blockToInsert = blockName;
  }
}

/*
  ===============================
  ======= Tools Service =========
  ===============================
*/
// Common base class for all tools
class BaseTool {
  constructor(viewModel) {
    this.viewModel = viewModel;
  }
  mouseDown(x, y, evt) {}
  mouseMove(x, y, evt) {}
  mouseUp(x, y, evt) {}
}

// SELECT tool
class SelectTool extends BaseTool {
  mouseDown(x, y, evt) {
    const shiftKey = evt.shiftKey;
    const hit = this.viewModel.findHitEntity(x, y);
    if (hit) {
      if (shiftKey) {
        hit.selected = !hit.selected;
      } else {
        this.viewModel.clearSelection();
        hit.selected = true;
      }
    } else {
      if (!shiftKey) {
        this.viewModel.clearSelection();
      }
    }
    this.viewModel.isDragging = true;
    this.viewModel.startX = x;
    this.viewModel.startY = y;
  }
  mouseMove(x, y, evt) {
    if (this.viewModel.isDragging) {
      const dx = x - this.viewModel.startX;
      const dy = y - this.viewModel.startY;
      this.viewModel.moveSelection(dx, dy);
      this.viewModel.startX = x;
      this.viewModel.startY = y;
    }
  }
  mouseUp(x, y, evt) {
    this.viewModel.isDragging = false;
  }
}

// LINE tool
class LineTool extends BaseTool {
  mouseDown(x, y, evt) {
    this.viewModel.tempEntity = new LineEntity(x, y, x, y);
    this.viewModel.drawing.entities.push(this.viewModel.tempEntity);
    this.viewModel.startX = x;
    this.viewModel.startY = y;
  }
  mouseMove(x, y, evt) {
    if (this.viewModel.tempEntity) {
      this.viewModel.tempEntity.x2 = x;
      this.viewModel.tempEntity.y2 = y;
    }
  }
  mouseUp(x, y, evt) {
    this.viewModel.tempEntity = null;
  }
}

// RECTANGLE tool (implemented as a closed polyline)
class RectTool extends BaseTool {
  mouseDown(x, y, evt) {
    this.viewModel.tempEntity = new PolylineEntity([
      {x: x, y: y},
      {x: x, y: y},
      {x: x, y: y},
      {x: x, y: y}
    ], true);
    this.viewModel.drawing.entities.push(this.viewModel.tempEntity);
    this.viewModel.startX = x;
    this.viewModel.startY = y;
  }
  mouseMove(x, y, evt) {
    if (this.viewModel.tempEntity) {
      this.viewModel.tempEntity.vertices = [
        {x: this.viewModel.startX, y: this.viewModel.startY},
        {x: x, y: this.viewModel.startY},
        {x: x, y: y},
        {x: this.viewModel.startX, y: y}
      ];
    }
  }
  mouseUp(x, y, evt) {
    this.viewModel.tempEntity = null;
  }
}

// CIRCLE tool
class CircleTool extends BaseTool {
  mouseDown(x, y, evt) {
    this.viewModel.tempEntity = new CircleEntity(x, y, 0);
    this.viewModel.drawing.entities.push(this.viewModel.tempEntity);
    this.viewModel.startX = x;
    this.viewModel.startY = y;
  }
  mouseMove(x, y, evt) {
    if (this.viewModel.tempEntity) {
      const dx = x - this.viewModel.tempEntity.cx;
      const dy = y - this.viewModel.tempEntity.cy;
      this.viewModel.tempEntity.r = Math.sqrt(dx * dx + dy * dy);
    }
  }
  mouseUp(x, y, evt) {
    this.viewModel.tempEntity = null;
  }
}

// TEXT tool
class TextTool extends BaseTool {
  mouseDown(x, y, evt) {
    const text = prompt("Enter text:", "Hello");
    if (text !== null) {
      const newEntity = new TextEntity(x, y, text);
      this.viewModel.drawing.entities.push(newEntity);
    }
  }
}

// POLYLINE tool
class PolylineTool extends BaseTool {
  mouseDown(x, y, evt) {
    if (!this.viewModel.tempEntity) {
      this.viewModel.tempEntity = new PolylineEntity([{x: x, y: y}, {x: x, y: y}], false);
      this.viewModel.drawing.entities.push(this.viewModel.tempEntity);
    } else {
      let first = this.viewModel.tempEntity.vertices[0];
      const dx = x - first.x;
      const dy = y - first.y;
      if (Math.sqrt(dx * dx + dy * dy) < 5 && this.viewModel.tempEntity.vertices.length > 2) {
        this.viewModel.tempEntity.vertices[this.viewModel.tempEntity.vertices.length - 1] = {x: first.x, y: first.y};
        this.viewModel.tempEntity.closed = true;
        this.viewModel.tempEntity = null;
      } else {
        this.viewModel.tempEntity.vertices[this.viewModel.tempEntity.vertices.length - 1] = {x: x, y: y};
        this.viewModel.tempEntity.vertices.push({x: x, y: y});
      }
    }
  }
  mouseMove(x, y, evt) {
    if (this.viewModel.tempEntity) {
      this.viewModel.tempEntity.vertices[this.viewModel.tempEntity.vertices.length - 1] = {x: x, y: y};
    }
  }
  mouseUp(x, y, evt) {
    // No action on mouseUp for polyline
  }
}

// INSERT BLOCK tool
class InsertBlockTool extends BaseTool {
  mouseDown(x, y, evt) {
    if (this.viewModel.blockToInsert) {
      const insertEnt = new InsertEntity(this.viewModel.blockToInsert, x, y);
      this.viewModel.drawing.entities.push(insertEnt);
    }
  }
}

// ToolsService ‚Äì delegates mouse events to the current tool.
class ToolsService {
  constructor(viewModel) {
    this.viewModel = viewModel;
    this.tools = {
      select: new SelectTool(viewModel),
      line: new LineTool(viewModel),
      rect: new RectTool(viewModel),
      circle: new CircleTool(viewModel),
      text: new TextTool(viewModel),
      polyline: new PolylineTool(viewModel),
      insertBlock: new InsertBlockTool(viewModel)
    };
    // The 'pan' tool is handled separately in CanvasRenderer.
    this.currentToolName = 'select';
    this.currentTool = this.tools[this.currentToolName];
  }

  setTool(toolName) {
    if (toolName === 'pan') {
      this.currentToolName = 'pan';
      this.currentTool = null;
    } else if (this.tools[toolName]) {
      this.currentToolName = toolName;
      this.currentTool = this.tools[toolName];
    }
  }

  mouseDown(x, y, evt) {
    if (this.currentToolName !== 'pan' && this.currentTool && this.currentTool.mouseDown) {
      this.currentTool.mouseDown(x, y, evt);
    }
  }

  mouseMove(x, y, evt) {
    if (this.currentToolName !== 'pan' && this.currentTool && this.currentTool.mouseMove) {
      this.currentTool.mouseMove(x, y, evt);
    }
  }

  mouseUp(x, y, evt) {
    if (this.currentToolName !== 'pan' && this.currentTool && this.currentTool.mouseUp) {
      this.currentTool.mouseUp(x, y, evt);
    }
  }
}

/*
  ===============================
  ========== CanvasRenderer ==========
  ===============================
*/
class CanvasRenderer {
  constructor(canvas, drawing, viewModel, toolsService) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.drawing = drawing;
    this.viewModel = viewModel;
    this.toolsService = toolsService;

    // Pan/Zoom properties
    this.panX = 0;
    this.panY = 0;
    this.scale = 1;
    this.isPanning = false;
    this.panStartX = 0;
    this.panStartY = 0;

    // Existing drawing events
    this.isMouseDown = false;
    this.lastX = 0;
    this.lastY = 0;

    // Mouse events
    this.canvas.addEventListener('mousedown', (evt) => this.onMouseDown(evt));
    this.canvas.addEventListener('mousemove', (evt) => this.onMouseMove(evt));
    this.canvas.addEventListener('mouseup', (evt) => this.onMouseUp(evt));
    this.canvas.addEventListener('wheel', (evt) => this.onWheel(evt));

    // Touch events for mobile devices
    this.canvas.addEventListener('touchstart', (evt) => this.onTouchStart(evt), {passive: false});
    this.canvas.addEventListener('touchmove', (evt) => this.onTouchMove(evt), {passive: false});
    this.canvas.addEventListener('touchend', (evt) => this.onTouchEnd(evt), {passive: false});

    requestAnimationFrame(() => this.renderLoop());
  }

  getMousePos(evt) {
    const rect = this.canvas.getBoundingClientRect();
    return { x: evt.clientX - rect.left, y: evt.clientY - rect.top };
  }

  getTouchPos(touch) {
    const rect = this.canvas.getBoundingClientRect();
    return { x: touch.clientX - rect.left, y: touch.clientY - rect.top };
  }

  onMouseDown(evt) {
    const pos = this.getMousePos(evt);
    const tx = (pos.x - this.panX) / this.scale;
    const ty = (pos.y - this.panY) / this.scale;
    
    // FIRST: Check if a resize handle was clicked on any selected entity.
    const HANDLE_SCREEN_SIZE = 8; // in pixels
    const handleSize = HANDLE_SCREEN_SIZE / this.scale; // size in drawing coordinates
    let handleClicked = false;
    for (let ent of this.drawing.entities) {
      if (ent.selected) {
        const bounds = BoundsService.getEntityBounds(ent);
        const handles = getSelectionHandles(bounds);
        for (let h of handles) {
          if (tx >= h.x - handleSize/2 && tx <= h.x + handleSize/2 &&
              ty >= h.y - handleSize/2 && ty <= h.y + handleSize/2) {
            // Begin resizing for this entity:
            this.viewModel.resizing = true;
            this.viewModel.resizingEntity = ent;
            this.viewModel.resizeHandle = h.id;
            // Clone the entity so we have its original state
            this.viewModel.resizeOriginalEntity = cloneEntity(ent);
            this.viewModel.resizeOriginalBounds = bounds;
            handleClicked = true;
            break;
          }
        }
      }
      if (handleClicked) break;
    }
    if (handleClicked) return; // skip normal tool handling if resizing

    if (this.toolsService.currentToolName === 'pan') {
      this.isPanning = true;
      this.panStartX = pos.x;
      this.panStartY = pos.y;
      return;
    }
    this.isMouseDown = true;
    this.lastX = pos.x;
    this.lastY = pos.y;
    const txTool = (pos.x - this.panX) / this.scale;
    const tyTool = (pos.y - this.panY) / this.scale;
    this.toolsService.mouseDown(txTool, tyTool, evt);
  }

  onMouseMove(evt) {
    const pos = this.getMousePos(evt);
    const tx = (pos.x - this.panX) / this.scale;
    const ty = (pos.y - this.panY) / this.scale;
    
    // If in resizing mode, update the entity geometry:
    if (this.viewModel.resizing) {
      const origBounds = this.viewModel.resizeOriginalBounds;
      let newBounds = Object.assign({}, origBounds);
      switch(this.viewModel.resizeHandle) {
        case 'nw': newBounds.minX = tx; newBounds.minY = ty; break;
        case 'n':  newBounds.minY = ty; break;
        case 'ne': newBounds.maxX = tx; newBounds.minY = ty; break;
        case 'e':  newBounds.maxX = tx; break;
        case 'se': newBounds.maxX = tx; newBounds.maxY = ty; break;
        case 's':  newBounds.maxY = ty; break;
        case 'sw': newBounds.minX = tx; newBounds.maxY = ty; break;
        case 'w':  newBounds.minX = tx; break;
      }
      const origWidth = origBounds.maxX - origBounds.minX;
      const origHeight = origBounds.maxY - origBounds.minY;
      const newWidth = newBounds.maxX - newBounds.minX;
      const newHeight = newBounds.maxY - newBounds.minY;
      const scaleX = origWidth !== 0 ? newWidth / origWidth : 1;
      const scaleY = origHeight !== 0 ? newHeight / origHeight : 1;
      
      updateEntityFromResize(
        this.viewModel.resizeOriginalEntity,
        this.viewModel.resizingEntity,
        origBounds,
        newBounds,
        scaleX,
        scaleY
      );
      return;
    }
    
    if (this.toolsService.currentToolName === 'pan' && this.isPanning) {
      let dx = pos.x - this.panStartX;
      let dy = pos.y - this.panStartY;
      this.panX += dx;
      this.panY += dy;
      this.panStartX = pos.x;
      this.panStartY = pos.y;
      return;
    }
    if (this.isMouseDown) {
      const txTool = (pos.x - this.panX) / this.scale;
      const tyTool = (pos.y - this.panY) / this.scale;
      this.toolsService.mouseMove(txTool, tyTool, evt);
    }
  }

  onMouseUp(evt) {
    const pos = this.getMousePos(evt);
    const tx = (pos.x - this.panX) / this.scale;
    const ty = (pos.y - this.panY) / this.scale;
    
    if (this.viewModel.resizing) {
      this.viewModel.resizing = false;
      this.viewModel.resizingEntity = null;
      this.viewModel.resizeHandle = null;
      this.viewModel.resizeOriginalEntity = null;
      this.viewModel.resizeOriginalBounds = null;
      return;
    }
    
    if (this.toolsService.currentToolName === 'pan') {
      this.isPanning = false;
      return;
    }
    this.isMouseDown = false;
    const txTool = (pos.x - this.panX) / this.scale;
    const tyTool = (pos.y - this.panY) / this.scale;
    this.toolsService.mouseUp(txTool, tyTool, evt);
  }

  onWheel(evt) {
    evt.preventDefault();
    const mousePos = this.getMousePos(evt);
    const x = (mousePos.x - this.panX) / this.scale;
    const y = (mousePos.y - this.panY) / this.scale;
    const zoomFactor = 1.1;
    if (evt.deltaY < 0) {
      this.scale *= zoomFactor;
    } else {
      this.scale /= zoomFactor;
    }
    this.panX = mousePos.x - x * this.scale;
    this.panY = mousePos.y - y * this.scale;
  }

  onTouchStart(evt) {
    evt.preventDefault();
    const touch = evt.touches[0];
    const pos = this.getTouchPos(touch);
    if (this.toolsService.currentToolName === 'pan') {
      this.isPanning = true;
      this.panStartX = pos.x;
      this.panStartY = pos.y;
      return;
    }
    this.isMouseDown = true;
    this.lastX = pos.x;
    this.lastY = pos.y;
    const tx = (pos.x - this.panX) / this.scale;
    const ty = (pos.y - this.panY) / this.scale;
    this.toolsService.mouseDown(tx, ty, evt);
  }

  onTouchMove(evt) {
    evt.preventDefault();
    const touch = evt.touches[0];
    const pos = this.getTouchPos(touch);
    if (this.toolsService.currentToolName === 'pan' && this.isPanning) {
      let dx = pos.x - this.panStartX;
      let dy = pos.y - this.panStartY;
      this.panX += dx;
      this.panY += dy;
      this.panStartX = pos.x;
      this.panStartY = pos.y;
      return;
    }
    if (this.isMouseDown) {
      const tx = (pos.x - this.panX) / this.scale;
      const ty = (pos.y - this.panY) / this.scale;
      this.toolsService.mouseMove(tx, ty, evt);
    }
  }

  onTouchEnd(evt) {
    evt.preventDefault();
    this.isMouseDown = false;
    const touch = evt.changedTouches[0];
    if (touch) {
      const pos = this.getTouchPos(touch);
      const tx = (pos.x - this.panX) / this.scale;
      const ty = (pos.y - this.panY) / this.scale;
      this.toolsService.mouseUp(tx, ty, evt);
    }
    this.isPanning = false;
  }

  renderLoop() {
    this.ctx.save();
    this.ctx.setTransform(1, 0, 0, 1, 0, 0);
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.ctx.restore();

    this.ctx.save();
    this.ctx.setTransform(this.scale, 0, 0, this.scale, this.panX, this.panY);
    for (let ent of this.drawing.entities) {
      DrawingService.drawEntity(ent, this.ctx, this.drawing.blocks);
    }
    // Draw selection handles for selected entities:
    const HANDLE_SCREEN_SIZE = 8;
    const handleSize = HANDLE_SCREEN_SIZE / this.scale;
    for (let ent of this.drawing.entities) {
      if (ent.selected) {
        const bounds = BoundsService.getEntityBounds(ent);
        const handles = getSelectionHandles(bounds);
        this.ctx.save();
        this.ctx.strokeStyle = 'blue';
        this.ctx.setLineDash([4/this.scale, 4/this.scale]);
        this.ctx.strokeRect(bounds.minX, bounds.minY, bounds.maxX - bounds.minX, bounds.maxY - bounds.minY);
        this.ctx.restore();
        this.ctx.fillStyle = 'white';
        this.ctx.strokeStyle = 'blue';
        for (let h of handles) {
          this.ctx.beginPath();
          this.ctx.rect(h.x - handleSize/2, h.y - handleSize/2, handleSize, handleSize);
          this.ctx.fill();
          this.ctx.stroke();
        }
      }
    }
    this.ctx.restore();
    requestAnimationFrame(() => this.renderLoop());
  }
}

/*
  ===============================
  ========== DXF I/O ============
  ===============================
*/
class DxfService {
  static exportDXF(drawing) {
    let dxf = [];
    dxf.push("0");
    dxf.push("SECTION");
    dxf.push("2");
    dxf.push("HEADER");
    dxf.push("9");
    dxf.push("$ACADVER");
    dxf.push("1");
    dxf.push("AC1009");
    dxf.push("0");
    dxf.push("ENDSEC");

    dxf.push("0");
    dxf.push("SECTION");
    dxf.push("2");
    dxf.push("BLOCKS");
    for (let blockName in drawing.blocks) {
      const block = drawing.blocks[blockName];
      dxf.push("0");
      dxf.push("BLOCK");
      dxf.push("2");
      dxf.push(blockName);
      dxf.push("70");
      dxf.push("0");
      dxf.push("10");
      dxf.push("0");
      dxf.push("20");
      dxf.push("0");
      for (let e of block.entities) {
        dxf.push(...this.entityToDXF(e));
      }
      dxf.push("0");
      dxf.push("ENDBLK");
    }
    dxf.push("0");
    dxf.push("ENDSEC");

    dxf.push("0");
    dxf.push("SECTION");
    dxf.push("2");
    dxf.push("ENTITIES");
    for (let e of drawing.entities) {
      dxf.push(...this.entityToDXF(e));
    }
    dxf.push("0");
    dxf.push("ENDSEC");
    dxf.push("0");
    dxf.push("EOF");

    return dxf.join("\n");
  }

  static entityToDXF(ent) {
    let result = [];
    if (ent instanceof LineEntity) {
      result.push("0");
      result.push("LINE");
      result.push("8");
      result.push("0");
      result.push("10");
      result.push(ent.x1);
      result.push("20");
      result.push(ent.y1);
      result.push("11");
      result.push(ent.x2);
      result.push("21");
      result.push(ent.y2);
    } else if (ent instanceof CircleEntity) {
      result.push("0");
      result.push("CIRCLE");
      result.push("8");
      result.push("0");
      result.push("10");
      result.push(ent.cx);
      result.push("20");
      result.push(ent.cy);
      result.push("40");
      result.push(ent.r);
    } else if (ent instanceof PolylineEntity) {
      result.push("0");
      result.push("POLYLINE");
      result.push("8");
      result.push("0");
      result.push("66");
      result.push("1");
      result.push("70");
      result.push(ent.closed ? "1" : "0");
      for (let v of ent.vertices) {
        result.push("0");
        result.push("VERTEX");
        result.push("8");
        result.push("0");
        result.push("10");
        result.push(v.x);
        result.push("20");
        result.push(v.y);
      }
      result.push("0");
      result.push("SEQEND");
    } else if (ent instanceof TextEntity) {
      result.push("0");
      result.push("TEXT");
      result.push("8");
      result.push("0");
      result.push("10");
      result.push(ent.x);
      result.push("20");
      result.push(ent.y);
      result.push("1");
      result.push(ent.text);
      result.push("40");
      result.push("16");
    } else if (ent instanceof InsertEntity) {
      result.push("0");
      result.push("INSERT");
      result.push("8");
      result.push("0");
      result.push("2");
      result.push(ent.blockName);
      result.push("10");
      result.push(ent.x);
      result.push("20");
      result.push(ent.y);
    }
    return result;
  }

  static importDXF(dxfString, drawing) {
    drawing.entities = [];
    drawing.blocks = {};
    const lines = dxfString.split(/\r?\n/).map(l => l.trim()).filter(l => l !== "");
    const pairs = [];
    for (let i = 0; i < lines.length; i += 2) {
      const code = lines[i];
      const value = lines[i + 1] || "";
      pairs.push({ code, value });
    }
    let index = 0;
    function nextPair() {
      return pairs[index++] || { code: null, value: null };
    }
    function peekPair() {
      return pairs[index] || { code: null, value: null };
    }
    function skipToNextEntity() {
      while (index < pairs.length && peekPair().code !== "0") {
        index++;
      }
    }
    function skipSection() {
      while (index < pairs.length) {
        let p = peekPair();
        if (p.code === "0" && (p.value === "ENDSEC" || p.value === "EOF")) {
          nextPair();
          break;
        }
        index++;
      }
    }
    function parseEntitiesInto(arrayRef) {
      while (index < pairs.length) {
        let pair = peekPair();
        if (pair.code === "0") {
          if (pair.value === "ENDSEC" || pair.value === "EOF") break;
          if (["LINE", "CIRCLE", "TEXT", "INSERT", "POLYLINE"].includes(pair.value)) {
            const entityData = parseOneEntity();
            const e = DxfService.convertDXFEntityToModel(entityData);
            if (e) arrayRef.push(e);
          } else {
            nextPair();
            skipToNextEntity();
          }
        } else {
          nextPair();
        }
      }
    }
    function parseBlocks() {
      while (index < pairs.length) {
        let pair = peekPair();
        if (pair.code === "0") {
          if (pair.value === "ENDSEC" || pair.value === "EOF") break;
          if (pair.value === "BLOCK") {
            parseOneBlock();
          } else {
            nextPair();
          }
        } else {
          nextPair();
        }
      }
    }
    function parseOneBlock() {
      nextPair();
      let blockName = "UnnamedBlock";
      const blockEntities = [];
      while (index < pairs.length) {
        let p = peekPair();
        if (p.code === "0") {
          if (p.value === "ENDBLK" || p.value === "EOF") {
            nextPair();
            break;
          }
          if (["LINE", "CIRCLE", "TEXT", "INSERT", "POLYLINE"].includes(p.value)) {
            const entityData = parseOneEntity();
            blockEntities.push(entityData);
          } else {
            nextPair();
            skipToNextEntity();
          }
        } else {
          let current = nextPair();
          if (current.code === "2") {
            blockName = current.value;
          }
        }
      }
      const realEntities = blockEntities
        .map(e => DxfService.convertDXFEntityToModel(e))
        .filter(e => e !== null);
      drawing.blocks[blockName] = new Block(blockName, realEntities);
    }
    function parseVertex() {
      let vertexType = nextPair();
      let x = 0, y = 0;
      while (index < pairs.length) {
        let p = peekPair();
        if (p.code === "0") break;
        p = nextPair();
        if (p.code === "10") x = parseFloat(p.value);
        else if (p.code === "20") y = parseFloat(p.value);
      }
      return { x, y };
    }
    function parseOneEntity() {
      let first = nextPair();
      let type = first.value;
      if (type === "POLYLINE") {
        let vertices = [];
        let closed = false;
        while (index < pairs.length) {
          let next = peekPair();
          if (next.code === "0") {
            if (next.value === "VERTEX") {
              let vertexData = parseVertex();
              vertices.push(vertexData);
            } else if (next.value === "SEQEND") {
              nextPair();
              break;
            } else {
              break;
            }
          } else {
            let headerPair = nextPair();
            if (headerPair.code === "70") {
              closed = parseInt(headerPair.value) === 1;
            }
          }
        }
        return { type: "POLYLINE", vertices: vertices, closed: closed };
      } else {
        const data = { type };
        while (index < pairs.length) {
          let p = peekPair();
          if (p.code === "0") break;
          p = nextPair();
          const gc = p.code;
          const gv = p.value;
          switch (type) {
            case "LINE":
              if (gc === "10") data.x1 = parseFloat(gv);
              else if (gc === "20") data.y1 = parseFloat(gv);
              else if (gc === "11") data.x2 = parseFloat(gv);
              else if (gc === "21") data.y2 = parseFloat(gv);
              break;
            case "CIRCLE":
              if (gc === "10") data.cx = parseFloat(gv);
              else if (gc === "20") data.cy = parseFloat(gv);
              else if (gc === "40") data.r = parseFloat(gv);
              break;
            case "TEXT":
              if (gc === "10") data.x = parseFloat(gv);
              else if (gc === "20") data.y = parseFloat(gv);
              else if (gc === "1") data.text = gv;
              break;
            case "INSERT":
              if (gc === "2") data.blockName = gv;
              else if (gc === "10") data.x = parseFloat(gv);
              else if (gc === "20") data.y = parseFloat(gv);
              break;
          }
        }
        return data;
      }
    }
    while (index < pairs.length) {
      let pair = nextPair();
      if (pair.code === "0" && pair.value === "SECTION") {
        let secPair = nextPair();
        if (secPair.code === "2") {
          let sectionName = secPair.value.toUpperCase();
          if (sectionName === "HEADER") {
            skipSection();
          } else if (sectionName === "BLOCKS") {
            parseBlocks();
            skipSection();
          } else if (sectionName === "ENTITIES") {
            parseEntitiesInto(drawing.entities);
            skipSection();
          } else {
            skipSection();
          }
        }
      } else if (pair.code === "0" && pair.value === "EOF") {
        break;
      }
    }
  }

  static convertDXFEntityToModel(e) {
    if (e.type === 'LINE') {
      return new LineEntity(e.x1 || 0, e.y1 || 0, e.x2 || 0, e.y2 || 0);
    } else if (e.type === 'CIRCLE') {
      return new CircleEntity(e.cx || 0, e.cy || 0, e.r || 0);
    } else if (e.type === 'TEXT') {
      return new TextEntity(e.x || 0, e.y || 0, e.text || "");
    } else if (e.type === 'INSERT') {
      return new InsertEntity(e.blockName || "?", e.x || 0, e.y || 0);
    } else if (e.type === 'POLYLINE') {
      return new PolylineEntity(e.vertices, e.closed);
    }
    return null;
  }
}

/*
  ===============================
  ========== Conversion =========
  ===============================
*/
function entityToObject(entity) {
  if (entity instanceof LineEntity) {
    return { type: "Line", x1: entity.x1, y1: entity.y1, x2: entity.x2, y2: entity.y2 };
  } else if (entity instanceof PolylineEntity) {
    return { type: "Polyline", vertices: entity.vertices, closed: entity.closed };
  } else if (entity instanceof CircleEntity) {
    return { type: "Circle", cx: entity.cx, cy: entity.cy, r: entity.r };
  } else if (entity instanceof TextEntity) {
    return { type: "Text", x: entity.x, y: entity.y, text: entity.text };
  } else if (entity instanceof InsertEntity) {
    return { type: "Insert", blockName: entity.blockName, x: entity.x, y: entity.y };
  }
  return null;
}

function objectToEntity(obj) {
  if (obj.type === "Line") {
    return new LineEntity(obj.x1, obj.y1, obj.x2, obj.y2);
  } else if (obj.type === "Polyline") {
    return new PolylineEntity(obj.vertices, obj.closed);
  } else if (obj.type === "Circle") {
    return new CircleEntity(obj.cx, obj.cy, obj.r);
  } else if (obj.type === "Text") {
    return new TextEntity(obj.x, obj.y, obj.text);
  } else if (obj.type === "Insert") {
    return new InsertEntity(obj.blockName, obj.x, obj.y);
  }
  return null;
}

/*
  ===============================
  ========== Editing UI =========
  ===============================
*/
let currentEditingEntityIndex = null;
let currentEditingBlockName = null;

document.getElementById('editEntity').addEventListener('click', () => {
  const selectedEntities = drawing.entities.filter(e => e.selected);
  if (selectedEntities.length !== 1) {
    alert("Please select exactly one entity to edit.");
    return;
  }
  currentEditingEntityIndex = drawing.entities.findIndex(e => e.selected);
  const entity = drawing.entities[currentEditingEntityIndex];
  const obj = entityToObject(entity);
  const jsonStr = JSON.stringify(obj, null, 2);
  document.getElementById('entityEditorTextarea').value = jsonStr;
  document.getElementById('entityEditorOverlay').style.display = 'block';
  document.getElementById('entityEditorModal').style.display = 'block';
});

document.getElementById('saveEntityEdit').addEventListener('click', () => {
  try {
    const jsonStr = document.getElementById('entityEditorTextarea').value;
    const obj = JSON.parse(jsonStr);
    const newEntity = objectToEntity(obj);
    if(newEntity === null) {
      alert("Invalid entity type.");
      return;
    }
    newEntity.selected = true;
    drawing.entities[currentEditingEntityIndex] = newEntity;
    document.getElementById('entityEditorOverlay').style.display = 'none';
    document.getElementById('entityEditorModal').style.display = 'none';
    currentEditingEntityIndex = null;
  } catch (e) {
    alert("Error parsing JSON: " + e.message);
  }
});

document.getElementById('cancelEntityEdit').addEventListener('click', () => {
  document.getElementById('entityEditorOverlay').style.display = 'none';
  document.getElementById('entityEditorModal').style.display = 'none';
  currentEditingEntityIndex = null;
});

document.getElementById('editBlock').addEventListener('click', () => {
  const name = prompt("Block name to edit:", "Block1");
  if (name && drawing.blocks[name]) {
    currentEditingBlockName = name;
    const block = drawing.blocks[name];
    const objs = block.entities.map(entityToObject);
    const jsonStr = JSON.stringify(objs, null, 2);
    document.getElementById('blockEditorTextarea').value = jsonStr;
    document.getElementById('blockEditorOverlay').style.display = 'block';
    document.getElementById('blockEditorModal').style.display = 'block';
  } else {
    alert("Block not found!");
  }
});

document.getElementById('saveBlockEdit').addEventListener('click', () => {
  try {
    const jsonStr = document.getElementById('blockEditorTextarea').value;
    const objs = JSON.parse(jsonStr);
    if (!Array.isArray(objs)) {
      alert("Invalid format: Expected an array of entities.");
      return;
    }
    const newEntities = objs.map(objectToEntity).filter(e => e !== null);
    drawing.blocks[currentEditingBlockName].entities = newEntities;
    document.getElementById('blockEditorOverlay').style.display = 'none';
    document.getElementById('blockEditorModal').style.display = 'none';
    currentEditingBlockName = null;
  } catch (e) {
    alert("Error parsing JSON: " + e.message);
  }
});

document.getElementById('cancelBlockEdit').addEventListener('click', () => {
  document.getElementById('blockEditorOverlay').style.display = 'none';
  document.getElementById('blockEditorModal').style.display = 'none';
  currentEditingBlockName = null;
});

/*
  ===============================
  ========== Main ===============
  ===============================
*/
const drawing = new Drawing();
const viewModel = new DrawingViewModel(drawing);
const toolsService = new ToolsService(viewModel);
const canvas = document.getElementById('drawingCanvas');
const renderer = new CanvasRenderer(canvas, drawing, viewModel, toolsService);

document.getElementById('newDrawing').addEventListener('click', () => {
  drawing.entities = [];
  drawing.blocks = {};
  renderer.panX = 0;
  renderer.panY = 0;
  renderer.scale = 1;
});

document.getElementById('panTool').addEventListener('click', () => {
  toolsService.setTool('pan');
});

document.getElementById('selectTool').addEventListener('click', () => {
  toolsService.setTool('select');
});

document.getElementById('lineTool').addEventListener('click', () => {
  toolsService.setTool('line');
});

document.getElementById('rectTool').addEventListener('click', () => {
  toolsService.setTool('rect');
});

document.getElementById('circleTool').addEventListener('click', () => {
  toolsService.setTool('circle');
});

document.getElementById('textTool').addEventListener('click', () => {
  toolsService.setTool('text');
});

document.getElementById('polylineTool').addEventListener('click', () => {
  toolsService.setTool('polyline');
});

document.getElementById('createBlock').addEventListener('click', () => {
  const name = prompt("Block name:", "Block1");
  if (name) {
    viewModel.createBlockFromSelection(name);
  }
});

document.getElementById('insertBlock').addEventListener('click', () => {
  const name = prompt("Block name to insert:", "Block1");
  if (name && drawing.blocks[name]) {
    viewModel.setBlockToInsert(name);
    toolsService.setTool('insertBlock');
  } else {
    alert("Block not found!");
  }
});

document.getElementById('saveDXF').addEventListener('click', () => {
  const dxfStr = DxfService.exportDXF(drawing);
  document.getElementById('dxfOutput').value = dxfStr;
  const blob = new Blob([dxfStr], {type: 'text/plain'});
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = 'drawing.dxf';
  link.click();
  URL.revokeObjectURL(url);
});

document.getElementById('loadDXFFile').addEventListener('change', (evt) => {
  const file = evt.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = function(e) {
    const contents = e.target.result;
    DxfService.importDXF(contents, drawing);
  };
  reader.readAsText(file);
});
</script>

</body>
</html>
