<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Minimal OOP Drawing App (MVVM, DXF) with Pan/Zoom, Block & Entity Editing with Resizing + Property Grid</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 16px;
    }
    #toolbar {
      margin-bottom: 8px;
    }
    button {
      margin-right: 4px;
      font-size: 20px;
    }
    textarea {
      width: 100%;
      height: 120px;
    }
    /* Block Toolbox Styles */
    #blockToolbox {
      border: 1px solid #ccc;
      padding: 4px;
      margin-bottom: 8px;
      display: flex;
      gap: 8px;
      overflow-x: auto;
    }
    .blockItem {
      border: 1px solid #aaa;
      padding: 4px;
      text-align: center;
      cursor: grab;
      background: #f9f9f9;
    }
    .blockItem canvas {
      display: block;
      margin: 0 auto;
      border: 1px solid #ccc;
    }
    /* Container holding the canvas and the property grid */
    #mainContainer {
      display: flex;
    }
    #canvasContainer {
      border: 1px solid #ccc;
      width: 800px;
      height: 600px;
      position: relative;
      overflow: hidden;
    }
    #drawingCanvas {
      position: absolute;
      top: 0;
      left: 0;
    }
    /* Property grid styles */
    #propertyGrid {
      width: 220px;
      margin-left: 8px;
      border: 1px solid #ccc;
      padding: 8px;
      height: 600px;
      overflow-y: auto;
    }
    /* Modal styles for block and entity editor */
    #blockEditorOverlay, #entityEditorOverlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.5);
      z-index: 900;
    }
    #blockEditorModal, #entityEditorModal {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #fff;
      border: 1px solid #ccc;
      padding: 16px;
      z-index: 1000;
      width: 400px;
      box-shadow: 0 0 10px rgba(0,0,0,0.5);
    }
    #blockEditorModal textarea, #entityEditorModal textarea {
      width: 100%;
      height: 200px;
    }
    #blockEditorModal button, #entityEditorModal button {
      margin-top: 8px;
      margin-right: 4px;
    }
  </style>
</head>
<body>

<div id="toolbar">
  <button id="newDrawing" title="New Drawing">üÜï</button>
  <button id="panTool" title="Pan">‚úã</button>
  <button id="selectTool" title="Select">üñ±</button>
  <button id="lineTool" title="Line">üìè</button>
  <button id="rectTool" title="Rectangle (via Polyline)">‚ñ≠</button>
  <button id="circleTool" title="Circle">‚ö™</button>
  <button id="textTool" title="Text">‚úèÔ∏è</button>
  <button id="polylineTool" title="Polyline">„Ä∞Ô∏è</button>
  <button id="createBlock" title="Create BLOCK from Selection">üì¶</button>
  <!-- You may keep or remove the old INSERT button -->
  <button id="insertBlock" title="INSERT Block">‚ûï</button>
  <button id="editBlock" title="Edit Block">üõ†Ô∏è</button>
  <button id="editEntity" title="Edit Entity (Modal)">üìù</button>
  <button id="saveDXF" title="Save DXF">üíæ</button>
  <input type="file" id="loadDXFFile" accept=".dxf,text/plain" />
</div>

<!-- New Block Toolbox -->
<div id="blockToolbox"></div>

<div id="mainContainer">
  <div id="canvasContainer">
    <canvas id="drawingCanvas" width="800" height="600"></canvas>
  </div>
  <div id="propertyGrid">
    <h3>Properties</h3>
    <div id="propertyGridContent">Select a single entity to edit its properties.</div>
  </div>
</div>

<p>
  <strong>DXF Output / Debug:</strong><br>
  <textarea id="dxfOutput" readonly></textarea>
</p>

<!-- Block Editor Modal -->
<div id="blockEditorOverlay"></div>
<div id="blockEditorModal">
  <h3>Edit Block</h3>
  <textarea id="blockEditorTextarea"></textarea>
  <br>
  <button id="saveBlockEdit">Save Block Edit</button>
  <button id="cancelBlockEdit">Cancel</button>
</div>

<!-- Entity Editor Modal -->
<div id="entityEditorOverlay"></div>
<div id="entityEditorModal">
  <h3>Edit Entity</h3>
  <textarea id="entityEditorTextarea"></textarea>
  <br>
  <button id="saveEntityEdit">Save Entity Edit</button>
  <button id="cancelEntityEdit">Cancel</button>
</div>

<script>
/*
  ===============================
  ========== Model ==============
  ===============================
*/

class Entity {
  constructor() {
    this.selected = false; // For selection highlight
  }
}

class LineEntity extends Entity {
  constructor(x1, y1, x2, y2) {
    super();
    this.x1 = x1;
    this.y1 = y1;
    this.x2 = x2;
    this.y2 = y2;
  }
  isHit(x, y) { return HitTestingService.isLineHit(this, x, y); }
  move(dx, dy) {
    this.x1 += dx;
    this.y1 += dy;
    this.x2 += dx;
    this.y2 += dy;
  }
}

class PolylineEntity extends Entity {
  constructor(vertices, closed = false) {
    super();
    this.vertices = vertices || [];
    this.closed = closed;
  }
  isHit(x, y) {
    return HitTestingService.isPolylineHit(this, x, y);
  }
  move(dx, dy) {
    this.vertices.forEach(v => {
      v.x += dx;
      v.y += dy;
    });
  }
}

class CircleEntity extends Entity {
  constructor(cx, cy, r) {
    super();
    this.cx = cx;
    this.cy = cy;
    this.r = r;
  }
  isHit(x, y) {
    return HitTestingService.isCircleHit(this, x, y);
  }
  move(dx, dy) {
    this.cx += dx;
    this.cy += dy;
  }
}

class TextEntity extends Entity {
  constructor(x, y, text) {
    super();
    this.x = x;
    this.y = y;
    this.text = text || "Text";
  }
  isHit(x, y) {
    return HitTestingService.isTextHit(this, x, y);
  }
  move(dx, dy) {
    this.x += dx;
    this.y += dy;
  }
}

/**
 * A block is essentially a named definition containing a list of entities.
 */
class Block {
  constructor(name, entities = []) {
    this.name = name;
    this.entities = entities.map(e => cloneEntity(e));
  }
}

/**
 * INSERT references a Block by name, with a position.
 */
class InsertEntity extends Entity {
  constructor(blockName, x, y) {
    super();
    this.blockName = blockName;
    this.x = x;
    this.y = y;
  }
  isHit(px, py) {
    return HitTestingService.isInsertHit(this, px, py, drawing.blocks);
  }
  move(dx, dy) {
    this.x += dx;
    this.y += dy;
  }
}

/**
 * The main Drawing model that contains top-level entities and block definitions.
 */
class Drawing {
  constructor() {
    this.entities = [];
    this.blocks = {}; // { blockName: Block, ... }
  }
}

/*
  ===============================
  ======= QuadTree Class ========
  ===============================
*/
class QuadTree {
  constructor(boundary, capacity) {
    // boundary: { x, y, w, h }
    this.boundary = boundary;
    this.capacity = capacity;
    this.entities = [];
    this.divided = false;
  }
  
  subdivide() {
    let x = this.boundary.x;
    let y = this.boundary.y;
    let w = this.boundary.w / 2;
    let h = this.boundary.h / 2;
    this.northeast = new QuadTree({x: x + w, y: y, w: w, h: h}, this.capacity);
    this.northwest = new QuadTree({x: x, y: y, w: w, h: h}, this.capacity);
    this.southeast = new QuadTree({x: x + w, y: y + h, w: w, h: h}, this.capacity);
    this.southwest = new QuadTree({x: x, y: y + h, w: w, h: h}, this.capacity);
    this.divided = true;
  }
  
  insert(obj) {
    // obj must have a 'bounds' property: {minX, minY, maxX, maxY}
    if (!this.intersects(obj.bounds)) {
      return false;
    }
    if (this.entities.length < this.capacity) {
      this.entities.push(obj);
      return true;
    }
    if (!this.divided) {
      this.subdivide();
    }
    if (this.northeast.insert(obj)) return true;
    if (this.northwest.insert(obj)) return true;
    if (this.southeast.insert(obj)) return true;
    if (this.southwest.insert(obj)) return true;
    return false;
  }
  
  intersects(rect) {
    // rect: {minX, minY, maxX, maxY}
    let b = this.boundary;
    if (rect.maxX < b.x || rect.minX > b.x + b.w || rect.maxY < b.y || rect.minY > b.y + b.h) {
      return false;
    }
    return true;
  }
  
  queryPoint(x, y, found) {
    if (!found) found = [];
    if (x < this.boundary.x || x > this.boundary.x + this.boundary.w ||
        y < this.boundary.y || y > this.boundary.y + this.boundary.h) {
      return found;
    }
    for (let obj of this.entities) {
      if (x >= obj.bounds.minX && x <= obj.bounds.maxX &&
          y >= obj.bounds.minY && y <= obj.bounds.maxY) {
        found.push(obj.entity);
      }
    }
    if (this.divided) {
      this.northwest.queryPoint(x, y, found);
      this.northeast.queryPoint(x, y, found);
      this.southwest.queryPoint(x, y, found);
      this.southeast.queryPoint(x, y, found);
    }
    return found;
  }
}

/*
  ===============================
  ======== Bounds Service =======
  ===============================
*/
class BoundsService {
  static getEntityBounds(e, blocks = {}) {
    if (e instanceof LineEntity) {
      return {
        minX: Math.min(e.x1, e.x2),
        minY: Math.min(e.y1, e.y2),
        maxX: Math.max(e.x1, e.x2),
        maxY: Math.max(e.y1, e.y2)
      };
    } else if (e instanceof PolylineEntity) {
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      e.vertices.forEach(v => {
        minX = Math.min(minX, v.x);
        minY = Math.min(minY, v.y);
        maxX = Math.max(maxX, v.x);
        maxY = Math.max(maxY, v.y);
      });
      return { minX, minY, maxX, maxY };
    } else if (e instanceof CircleEntity) {
      return {
        minX: e.cx - e.r,
        minY: e.cy - e.r,
        maxX: e.cx + e.r,
        maxY: e.cy + e.r
      };
    } else if (e instanceof TextEntity) {
      // Estimate text bounds using fixed values
      return {
        minX: e.x,
        minY: e.y - 16,
        maxX: e.x + 50,
        maxY: e.y
      };
    } else if (e instanceof InsertEntity) {
      let block = blocks[e.blockName];
      if (block && block.entities.length > 0) {
         let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
         block.entities.forEach(child => {
           let b = BoundsService.getEntityBounds(child, blocks);
           minX = Math.min(minX, b.minX);
           minY = Math.min(minY, b.minY);
           maxX = Math.max(maxX, b.maxX);
           maxY = Math.max(maxY, b.maxY);
         });
         return { minX: minX + e.x, minY: minY + e.y, maxX: maxX + e.x, maxY: maxY + e.y };
      }
      return { minX: e.x, minY: e.y, maxX: e.x, maxY: e.y };
    }
    return { minX: 0, minY: 0, maxX: 0, maxY: 0 };
  }
}

/*
  ===============================
  ========== Hit Testing =========
  ===============================
*/
class HitTestingService {
  static pointLineDistance(px, py, x1, y1, x2, y2) {
    const A = px - x1;
    const B = py - y1;
    const C = x2 - x1;
    const D = y2 - y1;
    const dot = A * C + B * D;
    const len_sq = C * C + D * D;
    let param = (len_sq !== 0) ? dot / len_sq : -1;
    let xx, yy;
    if (param < 0) {
      xx = x1; yy = y1;
    } else if (param > 1) {
      xx = x2; yy = y2;
    } else {
      xx = x1 + param * C;
      yy = y1 + param * D;
    }
    const dx = px - xx;
    const dy = py - yy;
    return Math.sqrt(dx * dx + dy * dy);
  }

  static isLineHit(entity, x, y) {
    return this.pointLineDistance(x, y, entity.x1, entity.y1, entity.x2, entity.y2) < 5;
  }

  static isPointInPolygon(x, y, vertices) {
    let inside = false;
    for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
      const xi = vertices[i].x, yi = vertices[i].y;
      const xj = vertices[j].x, yj = vertices[j].y;
      const intersect = ((yi > y) !== (yj > y)) &&
                        (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
      if (intersect) inside = !inside;
    }
    return inside;
  }

  static isPolylineHit(entity, x, y) {
    const threshold = 5;
    if (entity.vertices.length < 2) return false;
    
    if (entity.closed) {
      // Check all edges (using modulo for wrapping around)
      for (let i = 0; i < entity.vertices.length; i++) {
        let j = (i + 1) % entity.vertices.length;
        if (this.pointLineDistance(x, y,
                                   entity.vertices[i].x, entity.vertices[i].y,
                                   entity.vertices[j].x, entity.vertices[j].y) < threshold) {
          return true;
        }
      }
      // If not near any edge, check if the point is inside the polygon.
      if (this.isPointInPolygon(x, y, entity.vertices)) {
        return true;
      }
    } else {
      // Open polyline: check each segment
      for (let i = 0; i < entity.vertices.length - 1; i++) {
        if (this.pointLineDistance(x, y,
                                   entity.vertices[i].x, entity.vertices[i].y,
                                   entity.vertices[i+1].x, entity.vertices[i+1].y) < threshold) {
          return true;
        }
      }
    }
    return false;
  }

  static isCircleHit(entity, x, y) {
    const dx = entity.cx - x;
    const dy = entity.cy - y;
    return Math.sqrt(dx * dx + dy * dy) <= entity.r + 5;
  }

  static isTextHit(entity, x, y) {
    let width = 50;
    const tempCanvas = document.createElement('canvas').getContext('2d');
    tempCanvas.font = "16px sans-serif";
    width = tempCanvas.measureText(entity.text).width;
    const height = 16;
    return (x >= entity.x && x <= entity.x + width &&
            y <= entity.y && y >= entity.y - height);
  }

  static isInsertHit(entity, x, y, blocks) {
    const block = blocks[entity.blockName];
    if (block && block.entities.length > 0) {
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      block.entities.forEach(e => {
          const b = BoundsService.getEntityBounds(e, blocks);
          minX = Math.min(minX, b.minX);
          minY = Math.min(minY, b.minY);
          maxX = Math.max(maxX, b.maxX);
          maxY = Math.max(maxY, b.maxY);
      });
      minX += entity.x;
      minY += entity.y;
      maxX += entity.x;
      maxY += entity.y;
      if (x >= minX && x <= maxX && y >= minY && y <= maxY) return true;
    }
    const dx = x - entity.x;
    const dy = y - entity.y;
    return Math.sqrt(dx * dx + dy * dy) < 10;
  }
}

/*
  ===============================
  ========== Utilities ==========
  ===============================
*/

function cloneEntity(entity) {
  if (entity instanceof LineEntity) {
    return new LineEntity(entity.x1, entity.y1, entity.x2, entity.y2);
  } else if (entity instanceof PolylineEntity) {
    const verts = entity.vertices.map(v => ({x: v.x, y: v.y}));
    return new PolylineEntity(verts, entity.closed);
  } else if (entity instanceof CircleEntity) {
    return new CircleEntity(entity.cx, entity.cy, entity.r);
  } else if (entity instanceof TextEntity) {
    return new TextEntity(entity.x, entity.y, entity.text);
  } else if (entity instanceof InsertEntity) {
    return new InsertEntity(entity.blockName, entity.x, entity.y);
  }
  return null;
}

/*
  ===============================
  ========== Resize Service ==========
  ===============================
*/
class ResizeService {
  static getSelectionHandles(bounds) {
    const midX = (bounds.minX + bounds.maxX) / 2;
    const midY = (bounds.minY + bounds.maxY) / 2;
    return [
      { id: 'nw', x: bounds.minX, y: bounds.minY },
      { id: 'n',  x: midX,       y: bounds.minY },
      { id: 'ne', x: bounds.maxX, y: bounds.minY },
      { id: 'e',  x: bounds.maxX, y: midY },
      { id: 'se', x: bounds.maxX, y: bounds.maxY },
      { id: 's',  x: midX,       y: bounds.maxY },
      { id: 'sw', x: bounds.minX, y: bounds.maxY },
      { id: 'w',  x: bounds.minX, y: midY }
    ];
  }

  static calculateNewBounds(origBounds, handle, x, y) {
    let newBounds = Object.assign({}, origBounds);
    switch (handle) {
      case 'nw': newBounds.minX = x; newBounds.minY = y; break;
      case 'n':  newBounds.minY = y; break;
      case 'ne': newBounds.maxX = x; newBounds.minY = y; break;
      case 'e':  newBounds.maxX = x; break;
      case 'se': newBounds.maxX = x; newBounds.maxY = y; break;
      case 's':  newBounds.maxY = y; break;
      case 'sw': newBounds.minX = x; newBounds.maxY = y; break;
      case 'w':  newBounds.minX = x; break;
    }
    return newBounds;
  }

  static updateEntityFromResize(original, current, origBounds, newBounds) {
    const origWidth = origBounds.maxX - origBounds.minX;
    const origHeight = origBounds.maxY - origBounds.minY;
    const newWidth = newBounds.maxX - newBounds.minX;
    const newHeight = newBounds.maxY - newBounds.minY;
    const scaleX = origWidth !== 0 ? newWidth / origWidth : 1;
    const scaleY = origHeight !== 0 ? newHeight / origHeight : 1;

    if (original instanceof LineEntity) {
      current.x1 = newBounds.minX + (original.x1 - origBounds.minX) * scaleX;
      current.y1 = newBounds.minY + (original.y1 - origBounds.minY) * scaleY;
      current.x2 = newBounds.minX + (original.x2 - origBounds.minX) * scaleX;
      current.y2 = newBounds.minY + (original.y2 - origBounds.minY) * scaleY;
    } else if (original instanceof PolylineEntity) {
      current.vertices = original.vertices.map(v => ({
        x: newBounds.minX + (v.x - origBounds.minX) * scaleX,
        y: newBounds.minY + (v.y - origBounds.minY) * scaleY
      }));
    } else if (original instanceof CircleEntity) {
      current.cx = newBounds.minX + (original.cx - origBounds.minX) * scaleX;
      current.cy = newBounds.minY + (original.cy - origBounds.minY) * scaleY;
      current.r = original.r * ((scaleX + scaleY) / 2);
    } else if (original instanceof TextEntity) {
      current.x = newBounds.minX + (original.x - origBounds.minX) * scaleX;
      current.y = newBounds.minY + (original.y - origBounds.minY) * scaleY;
    } else if (original instanceof InsertEntity) {
      current.x = newBounds.minX + (original.x - origBounds.minX) * scaleX;
      current.y = newBounds.minY + (original.y - origBounds.minY) * scaleY;
    }
  }
}

/*
  ===============================
  ========== Drawing Service ==========
  ===============================
*/
class DrawingService {
  static drawEntity(entity, ctx, blocks) {
    if (entity instanceof LineEntity) {
      ctx.save();
      ctx.beginPath();
      ctx.strokeStyle = entity.selected ? 'red' : 'black';
      ctx.moveTo(entity.x1, entity.y1);
      ctx.lineTo(entity.x2, entity.y2);
      ctx.stroke();
      ctx.restore();
    } else if (entity instanceof PolylineEntity) {
      if (entity.vertices.length === 0) return;
      ctx.save();
      ctx.beginPath();
      ctx.strokeStyle = entity.selected ? 'red' : 'black';
      ctx.moveTo(entity.vertices[0].x, entity.vertices[0].y);
      for (let i = 1; i < entity.vertices.length; i++) {
        ctx.lineTo(entity.vertices[i].x, entity.vertices[i].y);
      }
      if (entity.closed) {
        ctx.closePath();
      }
      ctx.stroke();
      ctx.restore();
    } else if (entity instanceof CircleEntity) {
      ctx.save();
      ctx.beginPath();
      ctx.strokeStyle = entity.selected ? 'red' : 'black';
      ctx.arc(entity.cx, entity.cy, entity.r, 0, 2 * Math.PI);
      ctx.stroke();
      ctx.restore();
    } else if (entity instanceof TextEntity) {
      ctx.save();
      ctx.font = "16px sans-serif";
      ctx.fillStyle = 'black';
      if (entity.selected) {
        ctx.strokeStyle = 'red';
        ctx.beginPath();
        ctx.moveTo(entity.x, entity.y);
        const textWidth = ctx.measureText(entity.text).width;
        ctx.lineTo(entity.x + textWidth, entity.y);
        ctx.stroke();
      }
      ctx.fillText(entity.text, entity.x, entity.y);
      ctx.restore();
    } else if (entity instanceof InsertEntity) {
      const block = blocks[entity.blockName];
      if (!block) return;
      ctx.save();
      ctx.translate(entity.x, entity.y);
      for (let e of block.entities) {
        DrawingService.drawEntity(e, ctx, blocks);
      }
      ctx.restore();
      if (entity.selected) {
        ctx.save();
        ctx.strokeStyle = 'red';
        ctx.beginPath();
        ctx.arc(entity.x, entity.y, 5, 0, 2 * Math.PI);
        ctx.stroke();
        ctx.restore();
      }
    }
  }
}

/*
  ===============================
  ========== ViewModel ==========
  ===============================
*/
class DrawingViewModel {
  constructor(drawing) {
    this.drawing = drawing;
    this.tempEntity = null;
    this.startX = 0;
    this.startY = 0;
    this.isDragging = false;
    this.blockToInsert = null;
    // NEW properties for resizing:
    this.resizing = false;
    this.resizingEntity = null;
    this.resizeHandle = null;
    this.resizeOriginalEntity = null;
    this.resizeOriginalBounds = null;
    // NEW properties for drag & drop block insertion:
    this.dragBlock = null; // block name being dragged
    this.dragBlockPos = { x: 0, y: 0 };
  }

  findHitEntity(x, y) {
    const drawingEntities = this.drawing.entities;
    let globalBounds = {minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity};
    drawingEntities.forEach(ent => {
      const b = BoundsService.getEntityBounds(ent, this.drawing.blocks);
      globalBounds.minX = Math.min(globalBounds.minX, b.minX);
      globalBounds.minY = Math.min(globalBounds.minY, b.minY);
      globalBounds.maxX = Math.max(globalBounds.maxX, b.maxX);
      globalBounds.maxY = Math.max(globalBounds.maxY, b.maxY);
    });
    if (globalBounds.minX === Infinity) {
      globalBounds = {minX: 0, minY: 0, maxX: 800, maxY: 600};
    }
    const boundary = { x: globalBounds.minX, y: globalBounds.minY, w: globalBounds.maxX - globalBounds.minX, h: globalBounds.maxY - globalBounds.minY };
    const qt = new QuadTree(boundary, 4);
    drawingEntities.forEach(ent => {
      const b = BoundsService.getEntityBounds(ent, this.drawing.blocks);
      qt.insert({ entity: ent, bounds: b });
    });

    // Query candidates at the click point.
    const candidates = qt.queryPoint(x, y);
    let hitEntities = [];

    // Check candidates in reverse drawing order.
    for (let i = drawingEntities.length - 1; i >= 0; i--) {
      let ent = drawingEntities[i];
      if (candidates.indexOf(ent) !== -1) {
        let hit = false;
        if (ent instanceof InsertEntity) {
          hit = HitTestingService.isInsertHit(ent, x, y, this.drawing.blocks);
        } else {
          hit = ent.isHit(x, y);
        }
        if (hit) hitEntities.push(ent);
      }
    }

    if (hitEntities.length === 0) return null;

    // If the top entity is already selected, cycle to the next.
    const selectedIndex = hitEntities.findIndex(e => e.selected);
    if (selectedIndex === -1) {
      return hitEntities[0];
    } else {
      // Returns the next entity in the list (wraps around)
      return hitEntities[(selectedIndex + 1) % hitEntities.length];
    }
  }

  clearSelection() {
    this.drawing.entities.forEach(e => e.selected = false);
  }

  moveSelection(dx, dy) {
    for (let ent of this.drawing.entities) {
      if (ent.selected) {
        ent.move(dx, dy);
      }
    }
  }

  offsetEntity(entity, dx, dy) {
    if (entity instanceof LineEntity) {
      return new LineEntity(entity.x1 - dx, entity.y1 - dy, entity.x2 - dx, entity.y2 - dy);
    } else if (entity instanceof PolylineEntity) {
      const newVerts = entity.vertices.map(v => ({x: v.x - dx, y: v.y - dy}));
      return new PolylineEntity(newVerts, entity.closed);
    } else if (entity instanceof CircleEntity) {
      return new CircleEntity(entity.cx - dx, entity.cy - dy, entity.r);
    } else if (entity instanceof TextEntity) {
      return new TextEntity(entity.x - dx, entity.y - dy, entity.text);
    }
    return null;
  }

  createBlockFromSelection(blockName) {
    const selectedEntities = this.drawing.entities.filter(e => e.selected);
    if (selectedEntities.length === 0) return;
    let globalBounds = null;
    selectedEntities.forEach(e => {
      const b = BoundsService.getEntityBounds(e, this.drawing.blocks);
      if (!globalBounds) {
        globalBounds = { minX: b.minX, minY: b.minY, maxX: b.maxX, maxY: b.maxY };
      } else {
        globalBounds.minX = Math.min(globalBounds.minX, b.minX);
        globalBounds.minY = Math.min(globalBounds.minY, b.minY);
        globalBounds.maxX = Math.max(globalBounds.maxX, b.maxX);
        globalBounds.maxY = Math.max(globalBounds.maxY, b.maxY);
      }
    });
    const offsetX = globalBounds.minX;
    const offsetY = globalBounds.minY;
    const offsetEntities = selectedEntities.map(e => this.offsetEntity(e, offsetX, offsetY))
                                            .filter(e => e !== null);
    this.drawing.blocks[blockName] = new Block(blockName, offsetEntities);
    selectedEntities.forEach(ent => { ent.selected = false; });
  }

  setBlockToInsert(blockName) {
    this.blockToInsert = blockName;
  }
}

/*
  ===============================
  ======= Tools Service =========
  ===============================
*/
class BaseTool {
  constructor(viewModel) {
    this.viewModel = viewModel;
  }
  mouseDown(x, y, evt) {}
  mouseMove(x, y, evt) {}
  mouseUp(x, y, evt) {}
}

class SelectTool extends BaseTool {
  mouseDown(x, y, evt) {
    const shiftKey = evt.shiftKey;
    const hit = this.viewModel.findHitEntity(x, y);
    if (hit) {
      if (shiftKey) {
        hit.selected = !hit.selected;
      } else {
        this.viewModel.clearSelection();
        hit.selected = true;
      }
    } else {
      if (!shiftKey) {
        this.viewModel.clearSelection();
      }
    }
    this.viewModel.isDragging = true;
    this.viewModel.startX = x;
    this.viewModel.startY = y;
  }
  mouseMove(x, y, evt) {
    if (this.viewModel.isDragging) {
      const dx = x - this.viewModel.startX;
      const dy = y - this.viewModel.startY;
      this.viewModel.moveSelection(dx, dy);
      this.viewModel.startX = x;
      this.viewModel.startY = y;
    }
  }
  mouseUp(x, y, evt) {
    this.viewModel.isDragging = false;
  }
}

class LineTool extends BaseTool {
  mouseDown(x, y, evt) {
    this.viewModel.tempEntity = new LineEntity(x, y, x, y);
    this.viewModel.drawing.entities.push(this.viewModel.tempEntity);
    this.viewModel.startX = x;
    this.viewModel.startY = y;
  }
  mouseMove(x, y, evt) {
    if (this.viewModel.tempEntity) {
      this.viewModel.tempEntity.x2 = x;
      this.viewModel.tempEntity.y2 = y;
    }
  }
  mouseUp(x, y, evt) {
    this.viewModel.tempEntity = null;
  }
}

class RectTool extends BaseTool {
  mouseDown(x, y, evt) {
    this.viewModel.tempEntity = new PolylineEntity([
      {x: x, y: y},
      {x: x, y: y},
      {x: x, y: y},
      {x: x, y: y}
    ], true);
    this.viewModel.drawing.entities.push(this.viewModel.tempEntity);
    this.viewModel.startX = x;
    this.viewModel.startY = y;
  }
  mouseMove(x, y, evt) {
    if (this.viewModel.tempEntity) {
      this.viewModel.tempEntity.vertices = [
        {x: this.viewModel.startX, y: this.viewModel.startY},
        {x: x, y: this.viewModel.startY},
        {x: x, y: y},
        {x: this.viewModel.startX, y: y}
      ];
    }
  }
  mouseUp(x, y, evt) {
    this.viewModel.tempEntity = null;
  }
}

class CircleTool extends BaseTool {
  mouseDown(x, y, evt) {
    this.viewModel.tempEntity = new CircleEntity(x, y, 0);
    this.viewModel.drawing.entities.push(this.viewModel.tempEntity);
    this.viewModel.startX = x;
    this.viewModel.startY = y;
  }
  mouseMove(x, y, evt) {
    if (this.viewModel.tempEntity) {
      const dx = x - this.viewModel.tempEntity.cx;
      const dy = y - this.viewModel.tempEntity.cy;
      this.viewModel.tempEntity.r = Math.sqrt(dx * dx + dy * dy);
    }
  }
  mouseUp(x, y, evt) {
    this.viewModel.tempEntity = null;
  }
}

class TextTool extends BaseTool {
  mouseDown(x, y, evt) {
    const text = prompt("Enter text:", "Hello");
    if (text !== null) {
      const newEntity = new TextEntity(x, y, text);
      this.viewModel.drawing.entities.push(newEntity);
    }
  }
}

class PolylineTool extends BaseTool {
  mouseDown(x, y, evt) {
    if (!this.viewModel.tempEntity) {
      this.viewModel.tempEntity = new PolylineEntity([{x: x, y: y}, {x: x, y: y}], false);
      this.viewModel.drawing.entities.push(this.viewModel.tempEntity);
    } else {
      let first = this.viewModel.tempEntity.vertices[0];
      const dx = x - first.x;
      const dy = y - first.y;
      if (Math.sqrt(dx * dx + dy * dy) < 5 && this.viewModel.tempEntity.vertices.length > 2) {
        this.viewModel.tempEntity.vertices[this.viewModel.tempEntity.vertices.length - 1] = {x: first.x, y: first.y};
        this.viewModel.tempEntity.closed = true;
        this.viewModel.tempEntity = null;
      } else {
        this.viewModel.tempEntity.vertices[this.viewModel.tempEntity.vertices.length - 1] = {x: x, y: y};
        this.viewModel.tempEntity.vertices.push({x: x, y: y});
      }
    }
  }
  mouseMove(x, y, evt) {
    if (this.viewModel.tempEntity) {
      this.viewModel.tempEntity.vertices[this.viewModel.tempEntity.vertices.length - 1] = {x: x, y: y};
    }
  }
  mouseUp(x, y, evt) {
    // No action needed on mouseUp for polyline
  }
}

class InsertBlockTool extends BaseTool {
  mouseDown(x, y, evt) {
    if (this.viewModel.blockToInsert) {
      const insertEnt = new InsertEntity(this.viewModel.blockToInsert, x, y);
      this.viewModel.drawing.entities.push(insertEnt);
    }
  }
}

class ToolsService {
  constructor(viewModel) {
    this.viewModel = viewModel;
    this.tools = {
      select: new SelectTool(viewModel),
      line: new LineTool(viewModel),
      rect: new RectTool(viewModel),
      circle: new CircleTool(viewModel),
      text: new TextTool(viewModel),
      polyline: new PolylineTool(viewModel),
      insertBlock: new InsertBlockTool(viewModel)
    };
    this.currentToolName = 'select';
    this.currentTool = this.tools[this.currentToolName];
  }

  setTool(toolName) {
    if (toolName === 'pan') {
      this.currentToolName = 'pan';
      this.currentTool = null;
    } else if (this.tools[toolName]) {
      this.currentToolName = toolName;
      this.currentTool = this.tools[toolName];
    }
  }

  mouseDown(x, y, evt) {
    if (this.currentToolName !== 'pan' && this.currentTool && this.currentTool.mouseDown) {
      this.currentTool.mouseDown(x, y, evt);
    }
  }

  mouseMove(x, y, evt) {
    if (this.currentToolName !== 'pan' && this.currentTool && this.currentTool.mouseMove) {
      this.currentTool.mouseMove(x, y, evt);
    }
  }

  mouseUp(x, y, evt) {
    if (this.currentToolName !== 'pan' && this.currentTool && this.currentTool.mouseUp) {
      this.currentTool.mouseUp(x, y, evt);
    }
  }
}

/*
  ===============================
  ========== CanvasRenderer ==========
  ===============================
*/
class CanvasRenderer {
  constructor(canvas, drawing, viewModel, toolsService) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.drawing = drawing;
    this.viewModel = viewModel;
    this.toolsService = toolsService;

    // Pan/Zoom properties
    this.panX = 0;
    this.panY = 0;
    this.scale = 1;
    this.isPanning = false;
    this.panStartX = 0;
    this.panStartY = 0;

    // Existing drawing events
    this.isMouseDown = false;
    this.lastX = 0;
    this.lastY = 0;

    // Mouse events
    this.canvas.addEventListener('mousedown', (evt) => this.onMouseDown(evt));
    this.canvas.addEventListener('mousemove', (evt) => this.onMouseMove(evt));
    this.canvas.addEventListener('mouseup', (evt) => this.onMouseUp(evt));
    this.canvas.addEventListener('wheel', (evt) => this.onWheel(evt));

    // Touch events for mobile devices
    this.canvas.addEventListener('touchstart', (evt) => this.onTouchStart(evt), {passive: false});
    this.canvas.addEventListener('touchmove', (evt) => this.onTouchMove(evt), {passive: false});
    this.canvas.addEventListener('touchend', (evt) => this.onTouchEnd(evt), {passive: false});

    // NEW: Drag & Drop events on the canvas for block insertion
    this.canvas.addEventListener('dragover', (evt) => {
      evt.preventDefault();
      const rect = this.canvas.getBoundingClientRect();
      const x = (evt.clientX - rect.left - this.panX) / this.scale;
      const y = (evt.clientY - rect.top - this.panY) / this.scale;
      this.viewModel.dragBlockPos = { x, y };
    });
    this.canvas.addEventListener('drop', (evt) => {
      evt.preventDefault();
      const blockName = this.viewModel.dragBlock;
      if (blockName && this.drawing.blocks[blockName]) {
         const rect = this.canvas.getBoundingClientRect();
         const x = (evt.clientX - rect.left - this.panX) / this.scale;
         const y = (evt.clientY - rect.top - this.panY) / this.scale;
         const insertEnt = new InsertEntity(blockName, x, y);
         this.drawing.entities.push(insertEnt);
      }
      this.viewModel.dragBlock = null;
    });

    requestAnimationFrame(() => this.renderLoop());
  }

  getMousePos(evt) {
    const rect = this.canvas.getBoundingClientRect();
    return { x: evt.clientX - rect.left, y: evt.clientY - rect.top };
  }

  getTouchPos(touch) {
    const rect = this.canvas.getBoundingClientRect();
    return { x: touch.clientX - rect.left, y: touch.clientY - rect.top };
  }

  onMouseDown(evt) {
    const pos = this.getMousePos(evt);
    const tx = (pos.x - this.panX) / this.scale;
    const ty = (pos.y - this.panY) / this.scale;
    
    // FIRST: Check if a resize handle was clicked on any selected entity.
    const HANDLE_SCREEN_SIZE = 8; // in pixels
    const handleSize = HANDLE_SCREEN_SIZE / this.scale; // in drawing coordinates
    let handleClicked = false;
    for (let ent of this.drawing.entities) {
      if (ent.selected) {
        const bounds = BoundsService.getEntityBounds(ent, this.viewModel.drawing.blocks);
        const handles = ResizeService.getSelectionHandles(bounds);
        for (let h of handles) {
          if (tx >= h.x - handleSize/2 && tx <= h.x + handleSize/2 &&
              ty >= h.y - handleSize/2 && ty <= h.y + handleSize/2) {
            // Begin resizing for this entity:
            this.viewModel.resizing = true;
            this.viewModel.resizingEntity = ent;
            this.viewModel.resizeHandle = h.id;
            this.viewModel.resizeOriginalEntity = cloneEntity(ent);
            this.viewModel.resizeOriginalBounds = bounds;
            handleClicked = true;
            break;
          }
        }
      }
      if (handleClicked) break;
    }
    if (handleClicked) return;

    if (this.toolsService.currentToolName === 'pan') {
      this.isPanning = true;
      this.panStartX = pos.x;
      this.panStartY = pos.y;
      return;
    }
    this.isMouseDown = true;
    this.lastX = pos.x;
    this.lastY = pos.y;
    const txTool = (pos.x - this.panX) / this.scale;
    const tyTool = (pos.y - this.panY) / this.scale;
    this.toolsService.mouseDown(txTool, tyTool, evt);
  }

  onMouseMove(evt) {
    const pos = this.getMousePos(evt);
    const tx = (pos.x - this.panX) / this.scale;
    const ty = (pos.y - this.panY) / this.scale;
    
    if (this.viewModel.resizing) {
      const origBounds = this.viewModel.resizeOriginalBounds;
      const newBounds = ResizeService.calculateNewBounds(origBounds, this.viewModel.resizeHandle, tx, ty);
      ResizeService.updateEntityFromResize(
        this.viewModel.resizeOriginalEntity,
        this.viewModel.resizingEntity,
        origBounds,
        newBounds
      );
      return;
    }
    
    if (this.toolsService.currentToolName === 'pan' && this.isPanning) {
      let dx = pos.x - this.panStartX;
      let dy = pos.y - this.panStartY;
      this.panX += dx;
      this.panY += dy;
      this.panStartX = pos.x;
      this.panStartY = pos.y;
      return;
    }
    if (this.isMouseDown) {
      const txTool = (pos.x - this.panX) / this.scale;
      const tyTool = (pos.y - this.panY) / this.scale;
      this.toolsService.mouseMove(txTool, tyTool, evt);
    }
  }

  onMouseUp(evt) {
    const pos = this.getMousePos(evt);
    const tx = (pos.x - this.panX) / this.scale;
    const ty = (pos.y - this.panY) / this.scale;
    
    if (this.viewModel.resizing) {
      this.viewModel.resizing = false;
      this.viewModel.resizingEntity = null;
      this.viewModel.resizeHandle = null;
      this.viewModel.resizeOriginalEntity = null;
      this.viewModel.resizeOriginalBounds = null;
      updatePropertyGrid();
      return;
    }
    
    if (this.toolsService.currentToolName === 'pan') {
      this.isPanning = false;
      return;
    }
    this.isMouseDown = false;
    const txTool = (pos.x - this.panX) / this.scale;
    const tyTool = (pos.y - this.panY) / this.scale;
    this.toolsService.mouseUp(txTool, tyTool, evt);
    updatePropertyGrid();
  }

  onWheel(evt) {
    evt.preventDefault();
    const mousePos = this.getMousePos(evt);
    const x = (mousePos.x - this.panX) / this.scale;
    const y = (mousePos.y - this.panY) / this.scale;
    const zoomFactor = 1.1;
    if (evt.deltaY < 0) {
      this.scale *= zoomFactor;
    } else {
      this.scale /= zoomFactor;
    }
    this.panX = mousePos.x - x * this.scale;
    this.panY = mousePos.y - y * this.scale;
  }

  onTouchStart(evt) {
    evt.preventDefault();
    const touch = evt.touches[0];
    const pos = this.getTouchPos(touch);
    if (this.toolsService.currentToolName === 'pan') {
      this.isPanning = true;
      this.panStartX = pos.x;
      this.panStartY = pos.y;
      return;
    }
    this.isMouseDown = true;
    this.lastX = pos.x;
    this.lastY = pos.y;
    const tx = (pos.x - this.panX) / this.scale;
    const ty = (pos.y - this.panY) / this.scale;
    this.toolsService.mouseDown(tx, ty, evt);
  }

  onTouchMove(evt) {
    evt.preventDefault();
    const touch = evt.touches[0];
    const pos = this.getTouchPos(touch);
    if (this.toolsService.currentToolName === 'pan' && this.isPanning) {
      let dx = pos.x - this.panStartX;
      let dy = pos.y - this.panStartY;
      this.panX += dx;
      this.panY += dy;
      this.panStartX = pos.x;
      this.panStartY = pos.y;
      return;
    }
    if (this.isMouseDown) {
      const tx = (pos.x - this.panX) / this.scale;
      const ty = (pos.y - this.panY) / this.scale;
      this.toolsService.mouseMove(tx, ty, evt);
    }
  }

  onTouchEnd(evt) {
    evt.preventDefault();
    this.isMouseDown = false;
    const touch = evt.changedTouches[0];
    if (touch) {
      const pos = this.getTouchPos(touch);
      const tx = (pos.x - this.panX) / this.scale;
      const ty = (pos.y - this.panY) / this.scale;
      this.toolsService.mouseUp(tx, ty, evt);
    }
    this.isPanning = false;
    updatePropertyGrid();
  }

  renderLoop() {
    this.ctx.save();
    this.ctx.setTransform(1, 0, 0, 1, 0, 0);
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.ctx.restore();

    this.ctx.save();
    this.ctx.setTransform(this.scale, 0, 0, this.scale, this.panX, this.panY);
    for (let ent of this.drawing.entities) {
      DrawingService.drawEntity(ent, this.ctx, this.drawing.blocks);
    }
    // Draw selection handles for selected entities:
    const HANDLE_SCREEN_SIZE = 8;
    const handleSize = HANDLE_SCREEN_SIZE / this.scale;
    for (let ent of this.drawing.entities) {
      if (ent.selected) {
        const bounds = BoundsService.getEntityBounds(ent, this.viewModel.drawing.blocks);
        const handles = ResizeService.getSelectionHandles(bounds);
        this.ctx.save();
        this.ctx.strokeStyle = 'blue';
        this.ctx.setLineDash([4/this.scale, 4/this.scale]);
        this.ctx.strokeRect(bounds.minX, bounds.minY, bounds.maxX - bounds.minX, bounds.maxY - bounds.minY);
        this.ctx.restore();
        this.ctx.fillStyle = 'white';
        this.ctx.strokeStyle = 'blue';
        for (let h of handles) {
          this.ctx.beginPath();
          this.ctx.rect(h.x - handleSize/2, h.y - handleSize/2, handleSize, handleSize);
          this.ctx.fill();
          this.ctx.stroke();
        }
      }
    }
    // NEW: If a block is being dragged, draw a ghost preview
    if (this.viewModel.dragBlock && this.drawing.blocks[this.viewModel.dragBlock]) {
      const block = this.drawing.blocks[this.viewModel.dragBlock];
      this.ctx.save();
      this.ctx.globalAlpha = 0.5;
      this.ctx.translate(this.viewModel.dragBlockPos.x, this.viewModel.dragBlockPos.y);
      for (let e of block.entities) {
        DrawingService.drawEntity(e, this.ctx, this.drawing.blocks);
      }
      this.ctx.restore();
    }
    this.ctx.restore();
    requestAnimationFrame(() => this.renderLoop());
  }
}

/*
  ===============================
  ========== DXF I/O ============
  ===============================
*/
class DxfService {
  static exportDXF(drawing) {
    let dxf = [];
    dxf.push("0");
    dxf.push("SECTION");
    dxf.push("2");
    dxf.push("HEADER");
    dxf.push("9");
    dxf.push("$ACADVER");
    dxf.push("1");
    dxf.push("AC1009");
    dxf.push("0");
    dxf.push("ENDSEC");

    dxf.push("0");
    dxf.push("SECTION");
    dxf.push("2");
    dxf.push("BLOCKS");
    for (let blockName in drawing.blocks) {
      const block = drawing.blocks[blockName];
      dxf.push("0");
      dxf.push("BLOCK");
      dxf.push("2");
      dxf.push(blockName);
      dxf.push("70");
      dxf.push("0");
      dxf.push("10");
      dxf.push("0");
      dxf.push("20");
      dxf.push("0");
      for (let e of block.entities) {
        dxf.push(...this.entityToDXF(e));
      }
      dxf.push("0");
      dxf.push("ENDBLK");
    }
    dxf.push("0");
    dxf.push("ENDSEC");

    dxf.push("0");
    dxf.push("SECTION");
    dxf.push("2");
    dxf.push("ENTITIES");
    for (let e of drawing.entities) {
      dxf.push(...this.entityToDXF(e));
    }
    dxf.push("0");
    dxf.push("ENDSEC");
    dxf.push("0");
    dxf.push("EOF");

    return dxf.join("\n");
  }

  static entityToDXF(ent) {
    let result = [];
    if (ent instanceof LineEntity) {
      result.push("0");
      result.push("LINE");
      result.push("8");
      result.push("0");
      result.push("10");
      result.push(ent.x1);
      result.push("20");
      result.push(ent.y1);
      result.push("11");
      result.push(ent.x2);
      result.push("21");
      result.push(ent.y2);
    } else if (ent instanceof CircleEntity) {
      result.push("0");
      result.push("CIRCLE");
      result.push("8");
      result.push("0");
      result.push("10");
      result.push(ent.cx);
      result.push("20");
      result.push(ent.cy);
      result.push("40");
      result.push(ent.r);
    } else if (ent instanceof PolylineEntity) {
      result.push("0");
      result.push("POLYLINE");
      result.push("8");
      result.push("0");
      result.push("66");
      result.push("1");
      result.push("70");
      result.push(ent.closed ? "1" : "0");
      for (let v of ent.vertices) {
        result.push("0");
        result.push("VERTEX");
        result.push("8");
        result.push("0");
        result.push("10");
        result.push(v.x);
        result.push("20");
        result.push(v.y);
      }
      result.push("0");
      result.push("SEQEND");
    } else if (ent instanceof TextEntity) {
      result.push("0");
      result.push("TEXT");
      result.push("8");
      result.push("0");
      result.push("10");
      result.push(ent.x);
      result.push("20");
      result.push(ent.y);
      result.push("1");
      result.push(ent.text);
      result.push("40");
      result.push("16");
    } else if (ent instanceof InsertEntity) {
      result.push("0");
      result.push("INSERT");
      result.push("8");
      result.push("0");
      result.push("2");
      result.push(ent.blockName);
      result.push("10");
      result.push(ent.x);
      result.push("20");
      result.push(ent.y);
    }
    return result;
  }

  static importDXF(dxfString, drawing) {
    drawing.entities = [];
    drawing.blocks = {};
    const lines = dxfString.split(/\r?\n/).map(l => l.trim()).filter(l => l !== "");
    const pairs = [];
    for (let i = 0; i < lines.length; i += 2) {
      const code = lines[i];
      const value = lines[i + 1] || "";
      pairs.push({ code, value });
    }
    let index = 0;
    function nextPair() {
      return pairs[index++] || { code: null, value: null };
    }
    function peekPair() {
      return pairs[index] || { code: null, value: null };
    }
    function skipToNextEntity() {
      while (index < pairs.length && peekPair().code !== "0") {
        index++;
      }
    }
    function skipSection() {
      while (index < pairs.length) {
        let p = peekPair();
        if (p.code === "0" && (p.value === "ENDSEC" || p.value === "EOF")) {
          nextPair();
          break;
        }
        index++;
      }
    }
    function parseEntitiesInto(arrayRef) {
      while (index < pairs.length) {
        let pair = peekPair();
        if (pair.code === "0") {
          if (pair.value === "ENDSEC" || pair.value === "EOF") break;
          if (["LINE", "CIRCLE", "TEXT", "INSERT", "POLYLINE"].includes(pair.value)) {
            const entityData = parseOneEntity();
            const e = DxfService.convertDXFEntityToModel(entityData);
            if (e) arrayRef.push(e);
          } else {
            nextPair();
            skipToNextEntity();
          }
        } else {
          nextPair();
        }
      }
    }
    function parseBlocks() {
      while (index < pairs.length) {
        let pair = peekPair();
        if (pair.code === "0") {
          if (pair.value === "ENDSEC" || pair.value === "EOF") break;
          if (pair.value === "BLOCK") {
            parseOneBlock();
          } else {
            nextPair();
          }
        } else {
          nextPair();
        }
      }
    }
    function parseOneBlock() {
      nextPair();
      let blockName = "UnnamedBlock";
      const blockEntities = [];
      while (index < pairs.length) {
        let p = peekPair();
        if (p.code === "0") {
          if (p.value === "ENDBLK" || p.value === "EOF") {
            nextPair();
            break;
          }
          if (["LINE", "CIRCLE", "TEXT", "INSERT", "POLYLINE"].includes(p.value)) {
            const entityData = parseOneEntity();
            blockEntities.push(entityData);
          } else {
            nextPair();
            skipToNextEntity();
          }
        } else {
          let current = nextPair();
          if (current.code === "2") {
            blockName = current.value;
          }
        }
      }
      const realEntities = blockEntities
        .map(e => DxfService.convertDXFEntityToModel(e))
        .filter(e => e !== null);
      drawing.blocks[blockName] = new Block(blockName, realEntities);
    }
    function parseVertex() {
      let vertexType = nextPair();
      let x = 0, y = 0;
      while (index < pairs.length) {
        let p = peekPair();
        if (p.code === "0") break;
        p = nextPair();
        if (p.code === "10") x = parseFloat(p.value);
        else if (p.code === "20") y = parseFloat(p.value);
      }
      return { x, y };
    }
    function parseOneEntity() {
      let first = nextPair();
      let type = first.value;
      if (type === "POLYLINE") {
        let vertices = [];
        let closed = false;
        while (index < pairs.length) {
          let next = peekPair();
          if (next.code === "0") {
            if (next.value === "VERTEX") {
              let vertexData = parseVertex();
              vertices.push(vertexData);
            } else if (next.value === "SEQEND") {
              nextPair();
              break;
            } else {
              break;
            }
          } else {
            let headerPair = nextPair();
            if (headerPair.code === "70") {
              closed = parseInt(headerPair.value) === 1;
            }
          }
        }
        return { type: "POLYLINE", vertices: vertices, closed: closed };
      } else {
        const data = { type };
        while (index < pairs.length) {
          let p = peekPair();
          if (p.code === "0") break;
          p = nextPair();
          const gc = p.code;
          const gv = p.value;
          switch (type) {
            case "LINE":
              if (gc === "10") data.x1 = parseFloat(gv);
              else if (gc === "20") data.y1 = parseFloat(gv);
              else if (gc === "11") data.x2 = parseFloat(gv);
              else if (gc === "21") data.y2 = parseFloat(gv);
              break;
            case "CIRCLE":
              if (gc === "10") data.cx = parseFloat(gv);
              else if (gc === "20") data.cy = parseFloat(gv);
              else if (gc === "40") data.r = parseFloat(gv);
              break;
            case "TEXT":
              if (gc === "10") data.x = parseFloat(gv);
              else if (gc === "20") data.y = parseFloat(gv);
              else if (gc === "1") data.text = gv;
              break;
            case "INSERT":
              if (gc === "2") data.blockName = gv;
              else if (gc === "10") data.x = parseFloat(gv);
              else if (gc === "20") data.y = parseFloat(gv);
              break;
          }
        }
        return data;
      }
    }
    while (index < pairs.length) {
      let pair = nextPair();
      if (pair.code === "0" && pair.value === "SECTION") {
        let secPair = nextPair();
        if (secPair.code === "2") {
          let sectionName = secPair.value.toUpperCase();
          if (sectionName === "HEADER") {
            skipSection();
          } else if (sectionName === "BLOCKS") {
            parseBlocks();
            skipSection();
          } else if (sectionName === "ENTITIES") {
            parseEntitiesInto(drawing.entities);
            skipSection();
          } else {
            skipSection();
          }
        }
      } else if (pair.code === "0" && pair.value === "EOF") {
        break;
      }
    }
  }

  static convertDXFEntityToModel(e) {
    if (e.type === 'LINE') {
      return new LineEntity(e.x1 || 0, e.y1 || 0, e.x2 || 0, e.y2 || 0);
    } else if (e.type === 'CIRCLE') {
      return new CircleEntity(e.cx || 0, e.cy || 0, e.r || 0);
    } else if (e.type === 'TEXT') {
      return new TextEntity(e.x || 0, e.y || 0, e.text || "");
    } else if (e.type === 'INSERT') {
      return new InsertEntity(e.blockName || "?", e.x || 0, e.y || 0);
    } else if (e.type === 'POLYLINE') {
      return new PolylineEntity(e.vertices, e.closed);
    }
    return null;
  }
}

/*
  ===============================
  ========== Conversion =========
  ===============================
*/
function entityToObject(entity) {
  if (entity instanceof LineEntity) {
    return { type: "Line", x1: entity.x1, y1: entity.y1, x2: entity.x2, y2: entity.y2 };
  } else if (entity instanceof PolylineEntity) {
    return { type: "Polyline", vertices: entity.vertices, closed: entity.closed };
  } else if (entity instanceof CircleEntity) {
    return { type: "Circle", cx: entity.cx, cy: entity.cy, r: entity.r };
  } else if (entity instanceof TextEntity) {
    return { type: "Text", x: entity.x, y: entity.y, text: entity.text };
  } else if (entity instanceof InsertEntity) {
    return { type: "Insert", blockName: entity.blockName, x: entity.x, y: entity.y };
  }
  return null;
}

function objectToEntity(obj) {
  if (obj.type === "Line") {
    return new LineEntity(obj.x1, obj.y1, obj.x2, obj.y2);
  } else if (obj.type === "Polyline") {
    return new PolylineEntity(obj.vertices, obj.closed);
  } else if (obj.type === "Circle") {
    return new CircleEntity(obj.cx, obj.cy, obj.r);
  } else if (obj.type === "Text") {
    return new TextEntity(obj.x, obj.y, obj.text);
  } else if (obj.type === "Insert") {
    return new InsertEntity(obj.blockName, obj.x, obj.y);
  }
  return null;
}

/*
  ===============================
  ========== Editing UI =========
  ===============================
*/
let currentEditingEntityIndex = null;
let currentEditingBlockName = null;

document.getElementById('editEntity').addEventListener('click', () => {
  const selectedEntities = drawing.entities.filter(e => e.selected);
  if (selectedEntities.length !== 1) {
    alert("Please select exactly one entity to edit.");
    return;
  }
  currentEditingEntityIndex = drawing.entities.findIndex(e => e.selected);
  const entity = drawing.entities[currentEditingEntityIndex];
  const obj = entityToObject(entity);
  const jsonStr = JSON.stringify(obj, null, 2);
  document.getElementById('entityEditorTextarea').value = jsonStr;
  document.getElementById('entityEditorOverlay').style.display = 'block';
  document.getElementById('entityEditorModal').style.display = 'block';
});

document.getElementById('saveEntityEdit').addEventListener('click', () => {
  try {
    const jsonStr = document.getElementById('entityEditorTextarea').value;
    const obj = JSON.parse(jsonStr);
    const newEntity = objectToEntity(obj);
    if(newEntity === null) {
      alert("Invalid entity type.");
      return;
    }
    newEntity.selected = true;
    drawing.entities[currentEditingEntityIndex] = newEntity;
    document.getElementById('entityEditorOverlay').style.display = 'none';
    document.getElementById('entityEditorModal').style.display = 'none';
    currentEditingEntityIndex = null;
    updatePropertyGrid();
  } catch (e) {
    alert("Error parsing JSON: " + e.message);
  }
});

document.getElementById('cancelEntityEdit').addEventListener('click', () => {
  document.getElementById('entityEditorOverlay').style.display = 'none';
  document.getElementById('entityEditorModal').style.display = 'none';
  currentEditingEntityIndex = null;
});

document.getElementById('editBlock').addEventListener('click', () => {
  const name = prompt("Block name to edit:", "Block1");
  if (name && drawing.blocks[name]) {
    currentEditingBlockName = name;
    const block = drawing.blocks[name];
    const objs = block.entities.map(entityToObject);
    const jsonStr = JSON.stringify(objs, null, 2);
    document.getElementById('blockEditorTextarea').value = jsonStr;
    document.getElementById('blockEditorOverlay').style.display = 'block';
    document.getElementById('blockEditorModal').style.display = 'block';
  } else {
    alert("Block not found!");
  }
});

document.getElementById('saveBlockEdit').addEventListener('click', () => {
  try {
    const jsonStr = document.getElementById('blockEditorTextarea').value;
    const objs = JSON.parse(jsonStr);
    if (!Array.isArray(objs)) {
      alert("Invalid format: Expected an array of entities.");
      return;
    }
    const newEntities = objs.map(objectToEntity).filter(e => e !== null);
    drawing.blocks[currentEditingBlockName].entities = newEntities;
    document.getElementById('blockEditorOverlay').style.display = 'none';
    document.getElementById('blockEditorModal').style.display = 'none';
    currentEditingBlockName = null;
    updateBlockToolbox();
  } catch (e) {
    alert("Error parsing JSON: " + e.message);
  }
});

document.getElementById('cancelBlockEdit').addEventListener('click', () => {
  document.getElementById('blockEditorOverlay').style.display = 'none';
  document.getElementById('blockEditorModal').style.display = 'none';
  currentEditingBlockName = null;
});

/*
  ===============================
  ========== Property Grid ======
  ===============================
*/
// Helper: recursively render fields for an object or array.
function renderPropertyFields(obj, parentKey = '') {
  let html = '';
  for (let key in obj) {
    let fullKey = parentKey ? parentKey + '.' + key : key;
    // For the "type" property, just show it.
    if (key === 'type') {
      html += '<div><strong>' + obj[key] + '</strong></div>';
    } else if (typeof obj[key] === 'object' && obj[key] !== null) {
      // If it's an array, iterate over its elements.
      if (Array.isArray(obj[key])) {
        html += `<fieldset style="padding:8px; margin:8px;"><legend>${key} (Array)</legend>`;
        obj[key].forEach((item, index) => {
          let itemKey = fullKey + '.' + index;
          if (typeof item === 'object' && item !== null) {
            html += renderPropertyFields(item, itemKey);
          } else {
            html += '<div style="margin-bottom: 4px;">' +
                    '<label>' + index + ': </label>' +
                    '<input type="text" name="' + itemKey + '" value="' + item + '" style="width: 80%;" />' +
                    '</div>';
          }
        });
        html += '</fieldset>';
      } else {
        // For a plain object, render a nested fieldset.
        html += `<fieldset style="padding:8px; margin:8px;"><legend>${key}</legend>`;
        html += renderPropertyFields(obj[key], fullKey);
        html += '</fieldset>';
      }
    } else {
      // For primitives, render a simple text input.
      html += '<div style="margin-bottom: 4px;">' +
              '<label>' + key + ': </label>' +
              '<input type="text" name="' + fullKey + '" value="' + obj[key] + '" style="width: 80%;" />' +
              '</div>';
    }
  }
  return html;
}

// Helper: update a nested property in an object based on a dot-delimited path.
function setValueByPath(obj, path, value, original) {
  const keys = path.split('.');
  const lastKey = keys.pop();
  let target = obj;
  let origTarget = original;
  for (let k of keys) {
    if (!(k in target)) {
      target[k] = {};
    }
    target = target[k];
    origTarget = origTarget ? origTarget[k] : undefined;
  }
  // Use original value type as a hint (for numbers, for example)
  let origVal = origTarget ? origTarget[lastKey] : undefined;
  if (typeof origVal === 'number') {
    target[lastKey] = parseFloat(value);
  } else {
    target[lastKey] = value;
  }
}

// New updatePropertyGrid() that uses recursive editing for sub-objects.
function updatePropertyGrid() {
  const propertyGridContent = document.getElementById('propertyGridContent');
  const selectedEntities = drawing.entities.filter(e => e.selected);
  if (selectedEntities.length !== 1) {
    propertyGridContent.innerHTML = "Select a single entity to edit its properties.";
    return;
  }
  const entity = selectedEntities[0];
  // Convert the entity into a plain object.
  const obj = entityToObject(entity);
  let html = '<form id="propertyGridForm">';
  html += renderPropertyFields(obj);
  html += '<button type="submit">Apply</button>';
  html += '</form>';
  propertyGridContent.innerHTML = html;
  
  const form = document.getElementById('propertyGridForm');
  form.addEventListener('submit', function(e) {
    e.preventDefault();
    const formData = new FormData(form);
    // Use a copy of the original object to help detect types.
    const originalObj = entityToObject(entity);
    for (let [key, value] of formData.entries()) {
      // Do not modify the "type" property.
      if (key === 'type') continue;
      setValueByPath(obj, key, value, originalObj);
    }
    // Recreate the entity from the updated object.
    const newEntity = objectToEntity(obj);
    if (newEntity) {
      newEntity.selected = true;
      // Replace the old entity in the drawing.
      const index = drawing.entities.indexOf(entity);
      drawing.entities[index] = newEntity;
    }
  });
}

/*
  ===============================
  ========== Block Toolbox ======
  ===============================
*/
function updateBlockToolbox() {
  const toolbox = document.getElementById('blockToolbox');
  toolbox.innerHTML = '';
  for (let blockName in drawing.blocks) {
    const block = drawing.blocks[blockName];
    const item = document.createElement('div');
    item.className = 'blockItem';
    item.draggable = true;
    item.dataset.blockName = blockName;
    // Create preview canvas
    const previewCanvas = document.createElement('canvas');
    const previewSize = 80;
    previewCanvas.width = previewSize;
    previewCanvas.height = previewSize;
    const ctx = previewCanvas.getContext('2d');
    // Compute block bounding box for scaling
    let bbox = {minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity};
    block.entities.forEach(e => {
      let b = BoundsService.getEntityBounds(e, drawing.blocks);
      bbox.minX = Math.min(bbox.minX, b.minX);
      bbox.minY = Math.min(bbox.minY, b.minY);
      bbox.maxX = Math.max(bbox.maxX, b.maxX);
      bbox.maxY = Math.max(bbox.maxY, b.maxY);
    });
    if (bbox.minX === Infinity) {
      bbox = {minX: 0, minY: 0, maxX: previewSize, maxY: previewSize};
    }
    const blockWidth = bbox.maxX - bbox.minX;
    const blockHeight = bbox.maxY - bbox.minY;
    const margin = 5;
    const scale = Math.min((previewSize - 2 * margin) / blockWidth, (previewSize - 2 * margin) / blockHeight);
    const offsetX = (previewSize - blockWidth * scale) / 2;
    const offsetY = (previewSize - blockHeight * scale) / 2;
    ctx.save();
    ctx.translate(offsetX, offsetY);
    ctx.scale(scale, scale);
    ctx.translate(-bbox.minX, -bbox.minY);
    block.entities.forEach(e => {
      DrawingService.drawEntity(e, ctx, drawing.blocks);
    });
    ctx.restore();
    
    const label = document.createElement('div');
    label.textContent = blockName;
    item.appendChild(previewCanvas);
    item.appendChild(label);
    
    // Drag event listeners
    item.addEventListener('dragstart', (evt) => {
      evt.dataTransfer.setData("text/plain", blockName);
      evt.dataTransfer.setDragImage(previewCanvas, previewCanvas.width/2, previewCanvas.height/2);
      viewModel.dragBlock = blockName;
    });
    item.addEventListener('dragend', (evt) => {
      viewModel.dragBlock = null;
    });
    
    toolbox.appendChild(item);
  }
}

/*
  ===============================
  ========== Main ===============
  ===============================
*/
const drawing = new Drawing();
const viewModel = new DrawingViewModel(drawing);
const toolsService = new ToolsService(viewModel);
const canvas = document.getElementById('drawingCanvas');
const renderer = new CanvasRenderer(canvas, drawing, viewModel, toolsService);

document.getElementById('newDrawing').addEventListener('click', () => {
  drawing.entities = [];
  drawing.blocks = {};
  renderer.panX = 0;
  renderer.panY = 0;
  renderer.scale = 1;
  updatePropertyGrid();
  updateBlockToolbox();
});

document.getElementById('panTool').addEventListener('click', () => {
  toolsService.setTool('pan');
});

document.getElementById('selectTool').addEventListener('click', () => {
  toolsService.setTool('select');
});

document.getElementById('lineTool').addEventListener('click', () => {
  toolsService.setTool('line');
});

document.getElementById('rectTool').addEventListener('click', () => {
  toolsService.setTool('rect');
});

document.getElementById('circleTool').addEventListener('click', () => {
  toolsService.setTool('circle');
});

document.getElementById('textTool').addEventListener('click', () => {
  toolsService.setTool('text');
});

document.getElementById('polylineTool').addEventListener('click', () => {
  toolsService.setTool('polyline');
});

document.getElementById('createBlock').addEventListener('click', () => {
  const name = prompt("Block name:", "Block1");
  if (name) {
    viewModel.createBlockFromSelection(name);
    updateBlockToolbox();
  }
});

document.getElementById('insertBlock').addEventListener('click', () => {
  const name = prompt("Block name to insert:", "Block1");
  if (name && drawing.blocks[name]) {
    viewModel.setBlockToInsert(name);
    toolsService.setTool('insertBlock');
  } else {
    alert("Block not found!");
  }
});

document.getElementById('saveDXF').addEventListener('click', () => {
  const dxfStr = DxfService.exportDXF(drawing);
  document.getElementById('dxfOutput').value = dxfStr;
  const blob = new Blob([dxfStr], {type: 'text/plain'});
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = 'drawing.dxf';
  link.click();
  URL.revokeObjectURL(url);
});

document.getElementById('loadDXFFile').addEventListener('change', (evt) => {
  const file = evt.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = function(e) {
    const contents = e.target.result;
    DxfService.importDXF(contents, drawing);
    updatePropertyGrid();
    updateBlockToolbox();
  };
  reader.readAsText(file);
});
</script>

</body>
</html>
