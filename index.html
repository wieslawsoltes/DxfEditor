<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Minimal OOP Drawing App (MVVM, DXF) with Pan/Zoom, Block & Entity Editing</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 16px;
    }
    #canvasContainer {
      border: 1px solid #ccc;
      width: 800px;
      height: 600px;
      position: relative;
      overflow: hidden;
    }
    #drawingCanvas {
      position: absolute;
      top: 0;
      left: 0;
    }
    #toolbar {
      margin-bottom: 8px;
    }
    button {
      margin-right: 4px;
      font-size: 20px;
    }
    textarea {
      width: 100%;
      height: 120px;
    }
    /* Modal styles for block editor */
    #blockEditorOverlay, #entityEditorOverlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.5);
      z-index: 900;
    }
    #blockEditorModal, #entityEditorModal {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #fff;
      border: 1px solid #ccc;
      padding: 16px;
      z-index: 1000;
      width: 400px;
      box-shadow: 0 0 10px rgba(0,0,0,0.5);
    }
    #blockEditorModal textarea, #entityEditorModal textarea {
      width: 100%;
      height: 200px;
    }
    #blockEditorModal button, #entityEditorModal button {
      margin-top: 8px;
      margin-right: 4px;
    }
  </style>
</head>
<body>

<div id="toolbar">
  <button id="newDrawing" title="New Drawing">üÜï</button>
  <button id="panTool" title="Pan">‚úã</button>
  <button id="selectTool" title="Select">üñ±</button>
  <button id="lineTool" title="Line">üìè</button>
  <button id="rectTool" title="Rectangle (via Polyline)">‚ñ≠</button>
  <button id="circleTool" title="Circle">‚ö™</button>
  <button id="textTool" title="Text">‚úèÔ∏è</button>
  <button id="polylineTool" title="Polyline">„Ä∞Ô∏è</button>
  <button id="createBlock" title="Create BLOCK from Selection">üì¶</button>
  <button id="insertBlock" title="INSERT Block">‚ûï</button>
  <button id="editBlock" title="Edit Block">üõ†Ô∏è</button>
  <button id="editEntity" title="Edit Entity">üìù</button>
  <button id="saveDXF" title="Save DXF">üíæ</button>
  <input type="file" id="loadDXFFile" accept=".dxf,text/plain" />
</div>

<div id="canvasContainer">
  <canvas id="drawingCanvas" width="800" height="600"></canvas>
</div>

<p>
  <strong>DXF Output / Debug:</strong><br>
  <textarea id="dxfOutput" readonly></textarea>
</p>

<!-- Block Editor Modal -->
<div id="blockEditorOverlay"></div>
<div id="blockEditorModal">
  <h3>Edit Block</h3>
  <textarea id="blockEditorTextarea"></textarea>
  <br>
  <button id="saveBlockEdit">Save Block Edit</button>
  <button id="cancelBlockEdit">Cancel</button>
</div>

<!-- Entity Editor Modal -->
<div id="entityEditorOverlay"></div>
<div id="entityEditorModal">
  <h3>Edit Entity</h3>
  <textarea id="entityEditorTextarea"></textarea>
  <br>
  <button id="saveEntityEdit">Save Entity Edit</button>
  <button id="cancelEntityEdit">Cancel</button>
</div>

<script>
/*
  ===============================
  ========== Model ==============
  ===============================
*/

class Entity {
  constructor() {
    this.selected = false; // For selection highlight
  }
  draw(ctx) {}
  isHit(x, y) { return false; }
  move(dx, dy) {}
}

class LineEntity extends Entity {
  constructor(x1, y1, x2, y2) {
    super();
    this.x1 = x1;
    this.y1 = y1;
    this.x2 = x2;
    this.y2 = y2;
  }

  draw(ctx) {
    ctx.save();
    ctx.beginPath();
    ctx.strokeStyle = this.selected ? 'red' : 'black';
    ctx.moveTo(this.x1, this.y1);
    ctx.lineTo(this.x2, this.y2);
    ctx.stroke();
    ctx.restore();
  }

  isHit(x, y) {
    return HitTestingService.isLineHit(this, x, y);
  }

  move(dx, dy) {
    this.x1 += dx;
    this.y1 += dy;
    this.x2 += dx;
    this.y2 += dy;
  }
}

class PolylineEntity extends Entity {
  constructor(vertices, closed = false) {
    super();
    this.vertices = vertices || [];
    this.closed = closed;
  }

  draw(ctx) {
    if (this.vertices.length === 0) return;
    ctx.save();
    ctx.beginPath();
    ctx.strokeStyle = this.selected ? 'red' : 'black';
    ctx.moveTo(this.vertices[0].x, this.vertices[0].y);
    for (let i = 1; i < this.vertices.length; i++) {
      ctx.lineTo(this.vertices[i].x, this.vertices[i].y);
    }
    if (this.closed) {
      ctx.closePath();
    }
    ctx.stroke();
    ctx.restore();
  }

  isHit(x, y) {
    return HitTestingService.isPolylineHit(this, x, y);
  }

  move(dx, dy) {
    this.vertices.forEach(v => {
      v.x += dx;
      v.y += dy;
    });
  }
}

class CircleEntity extends Entity {
  constructor(cx, cy, r) {
    super();
    this.cx = cx;
    this.cy = cy;
    this.r = r;
  }

  draw(ctx) {
    ctx.save();
    ctx.beginPath();
    ctx.strokeStyle = this.selected ? 'red' : 'black';
    ctx.arc(this.cx, this.cy, this.r, 0, 2*Math.PI);
    ctx.stroke();
    ctx.restore();
  }

  isHit(x, y) {
    return HitTestingService.isCircleHit(this, x, y);
  }

  move(dx, dy) {
    this.cx += dx;
    this.cy += dy;
  }
}

class TextEntity extends Entity {
  constructor(x, y, text) {
    super();
    this.x = x;
    this.y = y;
    this.text = text || "Text";
  }

  draw(ctx) {
    ctx.save();
    ctx.font = "16px sans-serif";
    ctx.fillStyle = 'black';
    if (this.selected) {
      ctx.strokeStyle = 'red';
      ctx.beginPath();
      ctx.moveTo(this.x, this.y);
      ctx.lineTo(this.x + ctx.measureText(this.text).width, this.y);
      ctx.stroke();
    }
    ctx.fillText(this.text, this.x, this.y);
    ctx.restore();
  }

  isHit(x, y) {
    return HitTestingService.isTextHit(this, x, y);
  }

  move(dx, dy) {
    this.x += dx;
    this.y += dy;
  }
}

/**
 * A block is essentially a named definition containing a list of entities.
 * We store them in their local coordinates.
 */
class Block {
  constructor(name, entities = []) {
    this.name = name;
    // Make a copy of entities in block definition
    this.entities = entities.map(e => cloneEntity(e));
  }
}

/**
 * INSERT references a Block by name, with a position.
 */
class InsertEntity extends Entity {
  constructor(blockName, x, y) {
    super();
    this.blockName = blockName;
    this.x = x;
    this.y = y;
  }

  draw(ctx, blocks) {
    const block = blocks[this.blockName];
    if (!block) return;

    ctx.save();
    ctx.translate(this.x, this.y);
    for (let e of block.entities) {
      ctx.save();
      e.draw(ctx);
      ctx.restore();
    }
    ctx.restore();

    if (this.selected) {
      ctx.save();
      ctx.strokeStyle = 'red';
      ctx.beginPath();
      ctx.arc(this.x, this.y, 5, 0, 2*Math.PI);
      ctx.stroke();
      ctx.restore();
    }
  }

  isHit(px, py) {
    // This basic fallback is not used when hit testing via the view model.
    const dx = px - this.x;
    const dy = py - this.y;
    return Math.sqrt(dx*dx + dy*dy) < 10;
  }

  move(dx, dy) {
    this.x += dx;
    this.y += dy;
  }
}

/**
 * The main Drawing model that contains top-level entities and block definitions.
 */
class Drawing {
  constructor() {
    this.entities = [];
    this.blocks = {}; // { blockName: Block, ... }
  }
}

/*
  ===============================
  ========== Hit Testing Service ==========
  ===============================
*/
class HitTestingService {
  static pointLineDistance(px, py, x1, y1, x2, y2) {
    const A = px - x1;
    const B = py - y1;
    const C = x2 - x1;
    const D = y2 - y1;
    const dot = A * C + B * D;
    const len_sq = C * C + D * D;
    let param = (len_sq !== 0) ? dot / len_sq : -1;
    let xx, yy;
    if (param < 0) {
      xx = x1; yy = y1;
    } else if (param > 1) {
      xx = x2; yy = y2;
    } else {
      xx = x1 + param * C;
      yy = y1 + param * D;
    }
    const dx = px - xx;
    const dy = py - yy;
    return Math.sqrt(dx * dx + dy * dy);
  }

  static isLineHit(entity, x, y) {
    return this.pointLineDistance(x, y, entity.x1, entity.y1, entity.x2, entity.y2) < 5;
  }

  static isPolylineHit(entity, x, y) {
    for (let i = 0; i < entity.vertices.length - 1; i++) {
      const v1 = entity.vertices[i];
      const v2 = entity.vertices[i + 1];
      if (this.pointLineDistance(x, y, v1.x, v1.y, v2.x, v2.y) < 5) {
        return true;
      }
    }
    if (entity.closed && entity.vertices.length > 1) {
      const v1 = entity.vertices[entity.vertices.length - 1];
      const v2 = entity.vertices[0];
      if (this.pointLineDistance(x, y, v1.x, v1.y, v2.x, v2.y) < 5) {
        return true;
      }
    }
    return false;
  }

  static isCircleHit(entity, x, y) {
    const dx = entity.cx - x;
    const dy = entity.cy - y;
    return Math.sqrt(dx * dx + dy * dy) <= entity.r + 5;
  }

  static isTextHit(entity, x, y) {
    let width = 50; // fallback width
    const tempCanvas = document.createElement('canvas').getContext('2d');
    tempCanvas.font = "16px sans-serif";
    width = tempCanvas.measureText(entity.text).width;
    const height = 16;
    return (x >= entity.x && x <= entity.x + width &&
            y <= entity.y && y >= entity.y - height);
  }

  static isInsertHit(entity, x, y, blocks, getEntityBoundsCallback) {
    const block = blocks[entity.blockName];
    if (block && block.entities.length > 0) {
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      block.entities.forEach(e => {
          const b = getEntityBoundsCallback(e);
          minX = Math.min(minX, b.minX);
          minY = Math.min(minY, b.minY);
          maxX = Math.max(maxX, b.maxX);
          maxY = Math.max(maxY, b.maxY);
      });
      minX += entity.x;
      minY += entity.y;
      maxX += entity.x;
      maxY += entity.y;
      if (x >= minX && x <= maxX && y >= minY && y <= maxY) return true;
    }
    const dx = x - entity.x;
    const dy = y - entity.y;
    return Math.sqrt(dx * dx + dy * dy) < 10;
  }
}

/*
  ===============================
  ========== Utilities ==========
  ===============================
*/

function cloneEntity(entity) {
  if (entity instanceof LineEntity) {
    return new LineEntity(entity.x1, entity.y1, entity.x2, entity.y2);
  } else if (entity instanceof PolylineEntity) {
    const verts = entity.vertices.map(v => ({x: v.x, y: v.y}));
    return new PolylineEntity(verts, entity.closed);
  } else if (entity instanceof CircleEntity) {
    return new CircleEntity(entity.cx, entity.cy, entity.r);
  } else if (entity instanceof TextEntity) {
    return new TextEntity(entity.x, entity.y, entity.text);
  } else if (entity instanceof InsertEntity) {
    return new InsertEntity(entity.blockName, entity.x, entity.y);
  }
  return null;
}

/*
  ===============================
  ========== ViewModel ==========
  ===============================
*/

class DrawingViewModel {
  constructor(drawing) {
    this.drawing = drawing;
    this.currentTool = 'select';
    this.tempEntity = null;
    this.startX = 0;
    this.startY = 0;
    this.isDragging = false;
    this.blockToInsert = null;
  }

  setTool(toolName) {
    this.currentTool = toolName;
    this.tempEntity = null;
    this.blockToInsert = null;
  }

  mouseDown(x, y, shiftKey) {
    if (this.currentTool === 'select') {
      const hit = this.findHitEntity(x, y);
      if (hit) {
        if (shiftKey) {
          hit.selected = !hit.selected;
        } else {
          this.clearSelection();
          hit.selected = true;
        }
      } else {
        if (!shiftKey) {
          this.clearSelection();
        }
      }
      this.isDragging = true;
      this.startX = x;
      this.startY = y;
    } else if (this.currentTool === 'line') {
      this.tempEntity = new LineEntity(x, y, x, y);
      this.drawing.entities.push(this.tempEntity);
      this.startX = x;
      this.startY = y;
    } else if (this.currentTool === 'rect') {
      // Draw rectangle using polyline
      this.tempEntity = new PolylineEntity([
        {x: x, y: y},
        {x: x, y: y},
        {x: x, y: y},
        {x: x, y: y}
      ], true);
      this.drawing.entities.push(this.tempEntity);
      this.startX = x;
      this.startY = y;
    } else if (this.currentTool === 'circle') {
      this.tempEntity = new CircleEntity(x, y, 0);
      this.drawing.entities.push(this.tempEntity);
      this.startX = x;
      this.startY = y;
    } else if (this.currentTool === 'text') {
      const text = prompt("Enter text:", "Hello");
      if (text !== null) {
        this.tempEntity = new TextEntity(x, y, text);
        this.drawing.entities.push(this.tempEntity);
      }
      this.tempEntity = null;
    } else if (this.currentTool === 'polyline') {
      if (!this.tempEntity) {
        // Start new polyline: add first point twice for preview
        this.tempEntity = new PolylineEntity([{x: x, y: y}, {x: x, y: y}], false);
        this.drawing.entities.push(this.tempEntity);
      } else {
        // Check if click is near first vertex to finish
        let first = this.tempEntity.vertices[0];
        const dx = x - first.x;
        const dy = y - first.y;
        if (Math.sqrt(dx*dx + dy*dy) < 5 && this.tempEntity.vertices.length > 2) {
          // Finish polyline and close it
          this.tempEntity.vertices[this.tempEntity.vertices.length - 1] = {x: first.x, y: first.y};
          this.tempEntity.closed = true;
          this.tempEntity = null;
        } else {
          // Commit current preview vertex and add a new preview
          this.tempEntity.vertices[this.tempEntity.vertices.length - 1] = {x: x, y: y};
          this.tempEntity.vertices.push({x: x, y: y});
        }
      }
    } else if (this.currentTool === 'insertBlock') {
      if (this.blockToInsert) {
        const insertEnt = new InsertEntity(this.blockToInsert, x, y);
        this.drawing.entities.push(insertEnt);
      }
    }
  }

  mouseMove(x, y) {
    if (this.currentTool === 'line' && this.tempEntity) {
      this.tempEntity.x2 = x;
      this.tempEntity.y2 = y;
    } else if (this.currentTool === 'rect' && this.tempEntity) {
      // Update rectangle vertices based on start point and current mouse position
      this.tempEntity.vertices = [
        {x: this.startX, y: this.startY},
        {x: x, y: this.startY},
        {x: x, y: y},
        {x: this.startX, y: y}
      ];
    } else if (this.currentTool === 'circle' && this.tempEntity) {
      const dx = x - this.tempEntity.cx;
      const dy = y - this.tempEntity.cy;
      this.tempEntity.r = Math.sqrt(dx*dx + dy*dy);
    } else if (this.currentTool === 'polyline' && this.tempEntity) {
      // Update the preview point
      this.tempEntity.vertices[this.tempEntity.vertices.length - 1] = {x: x, y: y};
    } else if (this.currentTool === 'select' && this.isDragging) {
      const dx = x - this.startX;
      const dy = y - this.startY;
      this.moveSelection(dx, dy);
      this.startX = x;
      this.startY = y;
    }
  }

  mouseUp(x, y) {
    this.isDragging = false;
    this.tempEntity = null;
  }

  findHitEntity(x, y) {
    for (let i = this.drawing.entities.length - 1; i >= 0; i--) {
      const ent = this.drawing.entities[i];
      let hit = false;
      if (ent instanceof InsertEntity) {
        hit = HitTestingService.isInsertHit(ent, x, y, this.drawing.blocks, this.getEntityBounds.bind(this));
      } else {
        hit = ent.isHit(x, y);
      }
      if (hit) return ent;
    }
    return null;
  }

  clearSelection() {
    this.drawing.entities.forEach(e => e.selected = false);
  }

  moveSelection(dx, dy) {
    for (let ent of this.drawing.entities) {
      if (ent.selected) {
        ent.move(dx, dy);
      }
    }
  }

  offsetEntity(entity, dx, dy) {
    if (entity instanceof LineEntity) {
      return new LineEntity(entity.x1 - dx, entity.y1 - dy, entity.x2 - dx, entity.y2 - dy);
    } else if (entity instanceof PolylineEntity) {
      const newVerts = entity.vertices.map(v => ({x: v.x - dx, y: v.y - dy}));
      return new PolylineEntity(newVerts, entity.closed);
    } else if (entity instanceof CircleEntity) {
      return new CircleEntity(entity.cx - dx, entity.cy - dy, entity.r);
    } else if (entity instanceof TextEntity) {
      return new TextEntity(entity.x - dx, entity.y - dy, entity.text);
    }
    return null;
  }

  createBlockFromSelection(blockName) {
    const selectedEntities = this.drawing.entities.filter(e => e.selected);
    if (selectedEntities.length === 0) return;
    let minX = Infinity, minY = Infinity;
    selectedEntities.forEach(e => {
      if (e instanceof LineEntity) {
        minX = Math.min(minX, e.x1, e.x2);
        minY = Math.min(minY, e.y1, e.y2);
      } else if (e instanceof PolylineEntity) {
        e.vertices.forEach(v => {
          minX = Math.min(minX, v.x);
          minY = Math.min(minY, v.y);
        });
      } else if (e instanceof CircleEntity) {
        minX = Math.min(minX, e.cx - e.r);
        minY = Math.min(minY, e.cy - e.r);
      } else if (e instanceof TextEntity) {
        minX = Math.min(minX, e.x);
        minY = Math.min(minY, e.y);
      }
    });
    const offsetEntities = selectedEntities.map(e => this.offsetEntity(e, minX, minY))
                                            .filter(e => e !== null);
    this.drawing.blocks[blockName] = new Block(blockName, offsetEntities);
    selectedEntities.forEach(ent => { ent.selected = false; });
  }

  setBlockToInsert(blockName) {
    this.currentTool = 'insertBlock';
    this.blockToInsert = blockName;
  }

  getEntityBounds(e) {
    if (e instanceof LineEntity) {
      return {
        minX: Math.min(e.x1, e.x2),
        minY: Math.min(e.y1, e.y2),
        maxX: Math.max(e.x1, e.x2),
        maxY: Math.max(e.y1, e.y2)
      };
    } else if (e instanceof PolylineEntity) {
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      e.vertices.forEach(v => {
        minX = Math.min(minX, v.x);
        minY = Math.min(minY, v.y);
        maxX = Math.max(maxX, v.x);
        maxY = Math.max(maxY, v.y);
      });
      return { minX, minY, maxX, maxY };
    } else if (e instanceof CircleEntity) {
      return {
        minX: e.cx - e.r,
        minY: e.cy - e.r,
        maxX: e.cx + e.r,
        maxY: e.cy + e.r
      };
    } else if (e instanceof TextEntity) {
      return {
        minX: e.x,
        minY: e.y - 16,
        maxX: e.x + 50,
        maxY: e.y
      };
    } else if (e instanceof InsertEntity) {
      return {
        minX: e.x,
        minY: e.y,
        maxX: e.x,
        maxY: e.y
      };
    }
    return { minX: 0, minY: 0, maxX: 0, maxY: 0 };
  }
}

/*
  ===============================
  ========== View ===============
  ===============================
*/

class CanvasRenderer {
  constructor(canvas, drawing, viewModel) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.drawing = drawing;
    this.viewModel = viewModel;

    // Pan/Zoom properties
    this.panX = 0;
    this.panY = 0;
    this.scale = 1;
    this.isPanning = false;
    this.panStartX = 0;
    this.panStartY = 0;

    // Existing drawing events
    this.isMouseDown = false;
    this.lastX = 0;
    this.lastY = 0;

    // Mouse events
    this.canvas.addEventListener('mousedown', (evt) => this.onMouseDown(evt));
    this.canvas.addEventListener('mousemove', (evt) => this.onMouseMove(evt));
    this.canvas.addEventListener('mouseup', (evt) => this.onMouseUp(evt));
    this.canvas.addEventListener('wheel', (evt) => this.onWheel(evt));

    // Touch events for mobile devices
    this.canvas.addEventListener('touchstart', (evt) => this.onTouchStart(evt), {passive: false});
    this.canvas.addEventListener('touchmove', (evt) => this.onTouchMove(evt), {passive: false});
    this.canvas.addEventListener('touchend', (evt) => this.onTouchEnd(evt), {passive: false});

    requestAnimationFrame(() => this.renderLoop());
  }

  getMousePos(evt) {
    const rect = this.canvas.getBoundingClientRect();
    return {
      x: evt.clientX - rect.left,
      y: evt.clientY - rect.top
    };
  }

  getTouchPos(touch) {
    const rect = this.canvas.getBoundingClientRect();
    return {
      x: touch.clientX - rect.left,
      y: touch.clientY - rect.top
    };
  }

  onMouseDown(evt) {
    const pos = this.getMousePos(evt);
    if (this.viewModel.currentTool === 'pan') {
      this.isPanning = true;
      this.panStartX = pos.x;
      this.panStartY = pos.y;
      return;
    }
    this.isMouseDown = true;
    this.lastX = pos.x;
    this.lastY = pos.y;
    // Convert mouse coordinates to drawing coordinates
    const tx = (pos.x - this.panX) / this.scale;
    const ty = (pos.y - this.panY) / this.scale;
    this.viewModel.mouseDown(tx, ty, evt.shiftKey);
  }

  onMouseMove(evt) {
    const pos = this.getMousePos(evt);
    if (this.viewModel.currentTool === 'pan' && this.isPanning) {
         let dx = pos.x - this.panStartX;
         let dy = pos.y - this.panStartY;
         this.panX += dx;
         this.panY += dy;
         this.panStartX = pos.x;
         this.panStartY = pos.y;
         return;
    }
    if (this.isMouseDown) {
         const tx = (pos.x - this.panX) / this.scale;
         const ty = (pos.y - this.panY) / this.scale;
         this.viewModel.mouseMove(tx, ty);
    }
  }

  onMouseUp(evt) {
    const pos = this.getMousePos(evt);
    if (this.viewModel.currentTool === 'pan') {
         this.isPanning = false;
         return;
    }
    this.isMouseDown = false;
    const tx = (pos.x - this.panX) / this.scale;
    const ty = (pos.y - this.panY) / this.scale;
    this.viewModel.mouseUp(tx, ty);
  }

  onWheel(evt) {
    evt.preventDefault();
    const mousePos = this.getMousePos(evt);
    // Convert mouse position to drawing coordinates before zooming
    const x = (mousePos.x - this.panX) / this.scale;
    const y = (mousePos.y - this.panY) / this.scale;
    const zoomFactor = 1.1;
    if (evt.deltaY < 0) {
      // Zoom in
      this.scale *= zoomFactor;
    } else {
      // Zoom out
      this.scale /= zoomFactor;
    }
    // Adjust pan so that the drawing point under the mouse remains fixed
    this.panX = mousePos.x - x * this.scale;
    this.panY = mousePos.y - y * this.scale;
  }

  onTouchStart(evt) {
    evt.preventDefault();
    const touch = evt.touches[0];
    const pos = this.getTouchPos(touch);
    if (this.viewModel.currentTool === 'pan') {
      this.isPanning = true;
      this.panStartX = pos.x;
      this.panStartY = pos.y;
      return;
    }
    this.isMouseDown = true;
    this.lastX = pos.x;
    this.lastY = pos.y;
    const tx = (pos.x - this.panX) / this.scale;
    const ty = (pos.y - this.panY) / this.scale;
    this.viewModel.mouseDown(tx, ty, false);
  }

  onTouchMove(evt) {
    evt.preventDefault();
    const touch = evt.touches[0];
    const pos = this.getTouchPos(touch);
    if (this.viewModel.currentTool === 'pan' && this.isPanning) {
      let dx = pos.x - this.panStartX;
      let dy = pos.y - this.panStartY;
      this.panX += dx;
      this.panY += dy;
      this.panStartX = pos.x;
      this.panStartY = pos.y;
      return;
    }
    if (this.isMouseDown) {
      const tx = (pos.x - this.panX) / this.scale;
      const ty = (pos.y - this.panY) / this.scale;
      this.viewModel.mouseMove(tx, ty);
    }
  }

  onTouchEnd(evt) {
    evt.preventDefault();
    this.isMouseDown = false;
    const touch = evt.changedTouches[0];
    if (touch) {
      const pos = this.getTouchPos(touch);
      const tx = (pos.x - this.panX) / this.scale;
      const ty = (pos.y - this.panY) / this.scale;
      this.viewModel.mouseUp(tx, ty);
    }
    this.isPanning = false;
  }

  renderLoop() {
    // Clear without transform
    this.ctx.save();
    this.ctx.setTransform(1, 0, 0, 1, 0, 0);
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.ctx.restore();

    // Apply pan/zoom transform
    this.ctx.save();
    this.ctx.setTransform(this.scale, 0, 0, this.scale, this.panX, this.panY);
    for (let ent of this.drawing.entities) {
      if (ent instanceof InsertEntity) {
        ent.draw(this.ctx, this.drawing.blocks);
      } else {
        ent.draw(this.ctx);
      }
    }
    this.ctx.restore();
    requestAnimationFrame(() => this.renderLoop());
  }
}

/*
  ===============================
  ======== DXF I/O ==============
  ===============================
*/

function exportDXF(drawing) {
  let dxf = [];
  dxf.push("0");
  dxf.push("SECTION");
  dxf.push("2");
  dxf.push("HEADER");
  dxf.push("9");
  dxf.push("$ACADVER");
  dxf.push("1");
  dxf.push("AC1009");
  dxf.push("0");
  dxf.push("ENDSEC");

  dxf.push("0");
  dxf.push("SECTION");
  dxf.push("2");
  dxf.push("BLOCKS");
  for (let blockName in drawing.blocks) {
    const block = drawing.blocks[blockName];
    dxf.push("0");
    dxf.push("BLOCK");
    dxf.push("2");
    dxf.push(blockName);
    dxf.push("70");
    dxf.push("0");
    dxf.push("10");
    dxf.push("0");
    dxf.push("20");
    dxf.push("0");
    for (let e of block.entities) {
      dxf.push(...entityToDXF(e));
    }
    dxf.push("0");
    dxf.push("ENDBLK");
  }
  dxf.push("0");
  dxf.push("ENDSEC");

  dxf.push("0");
  dxf.push("SECTION");
  dxf.push("2");
  dxf.push("ENTITIES");
  for (let e of drawing.entities) {
    dxf.push(...entityToDXF(e));
  }
  dxf.push("0");
  dxf.push("ENDSEC");
  dxf.push("0");
  dxf.push("EOF");

  return dxf.join("\n");
}

function entityToDXF(ent) {
  let result = [];
  if (ent instanceof LineEntity) {
    result.push("0");
    result.push("LINE");
    result.push("8");
    result.push("0");
    result.push("10");
    result.push(ent.x1);
    result.push("20");
    result.push(ent.y1);
    result.push("11");
    result.push(ent.x2);
    result.push("21");
    result.push(ent.y2);
  } else if (ent instanceof CircleEntity) {
    result.push("0");
    result.push("CIRCLE");
    result.push("8");
    result.push("0");
    result.push("10");
    result.push(ent.cx);
    result.push("20");
    result.push(ent.cy);
    result.push("40");
    result.push(ent.r);
  } else if (ent instanceof PolylineEntity) {
    result.push("0");
    result.push("POLYLINE");
    result.push("8");
    result.push("0");
    result.push("66");
    result.push("1");
    result.push("70");
    result.push(ent.closed ? "1" : "0");
    for (let v of ent.vertices) {
      result.push("0");
      result.push("VERTEX");
      result.push("8");
      result.push("0");
      result.push("10");
      result.push(v.x);
      result.push("20");
      result.push(v.y);
    }
    result.push("0");
    result.push("SEQEND");
  } else if (ent instanceof TextEntity) {
    result.push("0");
    result.push("TEXT");
    result.push("8");
    result.push("0");
    result.push("10");
    result.push(ent.x);
    result.push("20");
    result.push(ent.y);
    result.push("1");
    result.push(ent.text);
    result.push("40");
    result.push("16");
  } else if (ent instanceof InsertEntity) {
    result.push("0");
    result.push("INSERT");
    result.push("8");
    result.push("0");
    result.push("2");
    result.push(ent.blockName);
    result.push("10");
    result.push(ent.x);
    result.push("20");
    result.push(ent.y);
  }
  return result;
}

function importDXF(dxfString, drawing) {
  drawing.entities = [];
  drawing.blocks = {};
  const lines = dxfString.split(/\r?\n/).map(l => l.trim()).filter(l => l !== "");
  const pairs = [];
  for (let i = 0; i < lines.length; i += 2) {
    const code = lines[i];
    const value = lines[i + 1] || "";
    pairs.push({ code, value });
  }
  let index = 0;
  function nextPair() {
    return pairs[index++] || { code: null, value: null };
  }
  function peekPair() {
    return pairs[index] || { code: null, value: null };
  }
  function skipToNextEntity() {
    while (index < pairs.length && peekPair().code !== "0") {
      index++;
    }
  }
  function skipSection() {
    while (index < pairs.length) {
      let p = peekPair();
      if (p.code === "0" && (p.value === "ENDSEC" || p.value === "EOF")) {
        nextPair();
        break;
      }
      index++;
    }
  }
  function parseEntitiesInto(arrayRef) {
    while (index < pairs.length) {
      let pair = peekPair();
      if (pair.code === "0") {
        if (pair.value === "ENDSEC" || pair.value === "EOF") break;
        if (["LINE", "CIRCLE", "TEXT", "INSERT", "POLYLINE"].includes(pair.value)) {
          const entityData = parseOneEntity();
          const e = convertDXFEntityToModel(entityData);
          if (e) arrayRef.push(e);
        } else {
          nextPair();
          skipToNextEntity();
        }
      } else {
        nextPair();
      }
    }
  }
  function parseBlocks() {
    while (index < pairs.length) {
      let pair = peekPair();
      if (pair.code === "0") {
        if (pair.value === "ENDSEC" || pair.value === "EOF") break;
        if (pair.value === "BLOCK") {
          parseOneBlock();
        } else {
          nextPair();
        }
      } else {
        nextPair();
      }
    }
  }
  function parseOneBlock() {
    nextPair();
    let blockName = "UnnamedBlock";
    const blockEntities = [];
    while (index < pairs.length) {
      let p = peekPair();
      if (p.code === "0") {
        if (p.value === "ENDBLK" || p.value === "EOF") {
          nextPair();
          break;
        }
        if (["LINE", "CIRCLE", "TEXT", "INSERT", "POLYLINE"].includes(p.value)) {
          const entityData = parseOneEntity();
          blockEntities.push(entityData);
        } else {
          nextPair();
          skipToNextEntity();
        }
      } else {
        let current = nextPair();
        if (current.code === "2") {
          blockName = current.value;
        }
      }
    }
    const realEntities = blockEntities
      .map(e => convertDXFEntityToModel(e))
      .filter(e => e !== null);
    drawing.blocks[blockName] = new Block(blockName, realEntities);
  }
  function parseVertex() {
    let vertexType = nextPair(); // should be "VERTEX"
    let x = 0, y = 0;
    while (index < pairs.length) {
      let p = peekPair();
      if (p.code === "0") break;
      p = nextPair();
      if (p.code === "10") x = parseFloat(p.value);
      else if (p.code === "20") y = parseFloat(p.value);
    }
    return { x, y };
  }
  function parseOneEntity() {
    let first = nextPair();
    let type = first.value;
    if (type === "POLYLINE") {
      let vertices = [];
      let closed = false;
      while (index < pairs.length) {
        let next = peekPair();
        if (next.code === "0") {
          if (next.value === "VERTEX") {
            let vertexData = parseVertex();
            vertices.push(vertexData);
          } else if (next.value === "SEQEND") {
            nextPair();
            break;
          } else {
            break;
          }
        } else {
          let headerPair = nextPair();
          if (headerPair.code === "70") {
            closed = parseInt(headerPair.value) === 1;
          }
        }
      }
      return { type: "POLYLINE", vertices: vertices, closed: closed };
    } else {
      const data = { type };
      while (index < pairs.length) {
        let p = peekPair();
        if (p.code === "0") break;
        p = nextPair();
        const gc = p.code;
        const gv = p.value;
        switch (type) {
          case "LINE":
            if (gc === "10") data.x1 = parseFloat(gv);
            else if (gc === "20") data.y1 = parseFloat(gv);
            else if (gc === "11") data.x2 = parseFloat(gv);
            else if (gc === "21") data.y2 = parseFloat(gv);
            break;
          case "CIRCLE":
            if (gc === "10") data.cx = parseFloat(gv);
            else if (gc === "20") data.cy = parseFloat(gv);
            else if (gc === "40") data.r = parseFloat(gv);
            break;
          case "TEXT":
            if (gc === "10") data.x = parseFloat(gv);
            else if (gc === "20") data.y = parseFloat(gv);
            else if (gc === "1") data.text = gv;
            break;
          case "INSERT":
            if (gc === "2") data.blockName = gv;
            else if (gc === "10") data.x = parseFloat(gv);
            else if (gc === "20") data.y = parseFloat(gv);
            break;
        }
      }
      return data;
    }
  }
  while (index < pairs.length) {
    let pair = nextPair();
    if (pair.code === "0" && pair.value === "SECTION") {
      let secPair = nextPair();
      if (secPair.code === "2") {
        let sectionName = secPair.value.toUpperCase();
        if (sectionName === "HEADER") {
          skipSection();
        } else if (sectionName === "BLOCKS") {
          parseBlocks();
          skipSection();
        } else if (sectionName === "ENTITIES") {
          parseEntitiesInto(drawing.entities);
          skipSection();
        } else {
          skipSection();
        }
      }
    } else if (pair.code === "0" && pair.value === "EOF") {
      break;
    }
  }
}

function convertDXFEntityToModel(e) {
  if (e.type === 'LINE') {
    return new LineEntity(e.x1||0, e.y1||0, e.x2||0, e.y2||0);
  } else if (e.type === 'CIRCLE') {
    return new CircleEntity(e.cx||0, e.cy||0, e.r||0);
  } else if (e.type === 'TEXT') {
    return new TextEntity(e.x||0, e.y||0, e.text||"");
  } else if (e.type === 'INSERT') {
    return new InsertEntity(e.blockName||"?", e.x||0, e.y||0);
  } else if (e.type === 'POLYLINE') {
    return new PolylineEntity(e.vertices, e.closed);
  }
  return null;
}

/*
  ===============================
  ========== Conversion =========
  ===============================
*/
// These helper functions convert between an entity instance and a plain object
// representation for editing via JSON.
function entityToObject(entity) {
  if (entity instanceof LineEntity) {
    return { type: "Line", x1: entity.x1, y1: entity.y1, x2: entity.x2, y2: entity.y2 };
  } else if (entity instanceof PolylineEntity) {
    return { type: "Polyline", vertices: entity.vertices, closed: entity.closed };
  } else if (entity instanceof CircleEntity) {
    return { type: "Circle", cx: entity.cx, cy: entity.cy, r: entity.r };
  } else if (entity instanceof TextEntity) {
    return { type: "Text", x: entity.x, y: entity.y, text: entity.text };
  } else if (entity instanceof InsertEntity) {
    return { type: "Insert", blockName: entity.blockName, x: entity.x, y: entity.y };
  }
  return null;
}

function objectToEntity(obj) {
  if (obj.type === "Line") {
    return new LineEntity(obj.x1, obj.y1, obj.x2, obj.y2);
  } else if (obj.type === "Polyline") {
    return new PolylineEntity(obj.vertices, obj.closed);
  } else if (obj.type === "Circle") {
    return new CircleEntity(obj.cx, obj.cy, obj.r);
  } else if (obj.type === "Text") {
    return new TextEntity(obj.x, obj.y, obj.text);
  } else if (obj.type === "Insert") {
    return new InsertEntity(obj.blockName, obj.x, obj.y);
  }
  return null;
}

/*
  ===============================
  ========== Editing UI =========
  ===============================
*/
// For block editing we already have the modal and handlers.
// Now add support for editing a single entity.
let currentEditingEntityIndex = null;

document.getElementById('editEntity').addEventListener('click', () => {
  const selectedEntities = drawing.entities.filter(e => e.selected);
  if (selectedEntities.length !== 1) {
    alert("Please select exactly one entity to edit.");
    return;
  }
  currentEditingEntityIndex = drawing.entities.findIndex(e => e.selected);
  const entity = drawing.entities[currentEditingEntityIndex];
  const obj = entityToObject(entity);
  const jsonStr = JSON.stringify(obj, null, 2);
  document.getElementById('entityEditorTextarea').value = jsonStr;
  document.getElementById('entityEditorOverlay').style.display = 'block';
  document.getElementById('entityEditorModal').style.display = 'block';
});

document.getElementById('saveEntityEdit').addEventListener('click', () => {
  try {
    const jsonStr = document.getElementById('entityEditorTextarea').value;
    const obj = JSON.parse(jsonStr);
    const newEntity = objectToEntity(obj);
    if(newEntity === null) {
      alert("Invalid entity type.");
      return;
    }
    newEntity.selected = true;
    drawing.entities[currentEditingEntityIndex] = newEntity;
    document.getElementById('entityEditorOverlay').style.display = 'none';
    document.getElementById('entityEditorModal').style.display = 'none';
    currentEditingEntityIndex = null;
  } catch (e) {
    alert("Error parsing JSON: " + e.message);
  }
});

document.getElementById('cancelEntityEdit').addEventListener('click', () => {
  document.getElementById('entityEditorOverlay').style.display = 'none';
  document.getElementById('entityEditorModal').style.display = 'none';
  currentEditingEntityIndex = null;
});

/*
  ===============================
  ========== Main ===============
  ===============================
*/

(function(){
  const drawing = new Drawing();
  const viewModel = new DrawingViewModel(drawing);
  const canvas = document.getElementById('drawingCanvas');
  const renderer = new CanvasRenderer(canvas, drawing, viewModel);

  document.getElementById('newDrawing').addEventListener('click', ()=>{
    drawing.entities = [];
    drawing.blocks = {};
    // Reset pan/zoom view
    renderer.panX = 0;
    renderer.panY = 0;
    renderer.scale = 1;
  });

  document.getElementById('panTool').addEventListener('click', ()=>{
    viewModel.setTool('pan');
  });

  document.getElementById('selectTool').addEventListener('click', ()=>{
    viewModel.setTool('select');
  });
  document.getElementById('lineTool').addEventListener('click', ()=>{
    viewModel.setTool('line');
  });
  document.getElementById('rectTool').addEventListener('click', ()=>{
    viewModel.setTool('rect');
  });
  document.getElementById('circleTool').addEventListener('click', ()=>{
    viewModel.setTool('circle');
  });
  document.getElementById('textTool').addEventListener('click', ()=>{
    viewModel.setTool('text');
  });
  document.getElementById('polylineTool').addEventListener('click', ()=>{
    viewModel.setTool('polyline');
  });

  document.getElementById('createBlock').addEventListener('click', ()=>{
    const name = prompt("Block name:", "Block1");
    if (name) {
      viewModel.createBlockFromSelection(name);
    }
  });

  document.getElementById('insertBlock').addEventListener('click', ()=>{
    const name = prompt("Block name to insert:", "Block1");
    if (name && drawing.blocks[name]) {
      viewModel.setBlockToInsert(name);
    } else {
      alert("Block not found!");
    }
  });

  // Block Editing via modal JSON editor
  document.getElementById('editBlock').addEventListener('click', ()=>{
    const name = prompt("Block name to edit:", "Block1");
    if (name && drawing.blocks[name]) {
      currentEditingBlockName = name;
      const block = drawing.blocks[name];
      // Convert block entities to plain objects
      const objs = block.entities.map(entityToObject);
      const jsonStr = JSON.stringify(objs, null, 2);
      document.getElementById('blockEditorTextarea').value = jsonStr;
      document.getElementById('blockEditorOverlay').style.display = 'block';
      document.getElementById('blockEditorModal').style.display = 'block';
    } else {
      alert("Block not found!");
    }
  });

  document.getElementById('saveBlockEdit').addEventListener('click', ()=>{
    try {
      const jsonStr = document.getElementById('blockEditorTextarea').value;
      const objs = JSON.parse(jsonStr);
      if (!Array.isArray(objs)) {
        alert("Invalid format: Expected an array of entities.");
        return;
      }
      const newEntities = objs.map(objectToEntity).filter(e => e !== null);
      drawing.blocks[currentEditingBlockName].entities = newEntities;
      // Hide modal
      document.getElementById('blockEditorOverlay').style.display = 'none';
      document.getElementById('blockEditorModal').style.display = 'none';
      currentEditingBlockName = null;
    } catch (e) {
      alert("Error parsing JSON: " + e.message);
    }
  });

  document.getElementById('cancelBlockEdit').addEventListener('click', ()=>{
    document.getElementById('blockEditorOverlay').style.display = 'none';
    document.getElementById('blockEditorModal').style.display = 'none';
    currentEditingBlockName = null;
  });

  document.getElementById('saveDXF').addEventListener('click', ()=>{
    const dxfStr = exportDXF(drawing);
    document.getElementById('dxfOutput').value = dxfStr;
    const blob = new Blob([dxfStr], {type: 'text/plain'});
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = 'drawing.dxf';
    link.click();
    URL.revokeObjectURL(url);
  });

  document.getElementById('loadDXFFile').addEventListener('change', (evt)=>{
    const file = evt.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function(e) {
      const contents = e.target.result;
      importDXF(contents, drawing);
    };
    reader.readAsText(file);
  });
})();
</script>

</body>
</html>
